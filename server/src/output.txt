// app.module.ts
import {
  MiddlewareConsumer,
  Module,
  NestModule,
  RequestMethod,
} from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from './prisma/prisma.module';
import configuration from './config/configuration';
import { ThrottlerModule } from '@nestjs/throttler';
import { AuthModule } from './modules/auth/module/auth.module';
import { SessionMiddleware } from './modules/auth/middleware/session.middleware';
import { RateLimitMiddleware } from './modules/auth/middleware/rate-limit.middleware';
import { RedisModule } from './redis/redis.module';
import { PrismaService } from './prisma/prisma.service';
import { MiddlewareModule } from './modules/middleware/middleware.module';
import { HealthController } from './health/health.controller';
import { MailModule } from './modules/mail/mail.module';
import { ErrorHandlingService } from './common/errors/error-handling.service';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { MonitoringModule } from './common/monitoring/monitoring.module';
import { MetricsService } from './common/monitoring/metrics.service';
import { HealthModule } from './health/health.module';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';
import { ErrorModule } from './common/errors/error.module';
import { RequestSanitizerMiddleware } from './common/security/request-sanitizer.middleware';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [configuration],
    }),
    ThrottlerModule.forRoot([
      {
        ttl: 60000,
        limit: 10,
      },
    ]),
    PrismaModule,
    AuthModule,
    RedisModule,
    MiddlewareModule,
    MailModule,
    MonitoringModule,
    AuthModule,
    HealthModule,
    ErrorModule,
  ],
  controllers: [HealthController],
  providers: [
    PrismaService,
    ErrorHandlingService,
    MetricsService,
    {
      provide: APP_INTERCEPTOR,
      useClass: GlobalExceptionFilter,
    },
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(RequestSanitizerMiddleware).forRoutes('*');

    consumer
      .apply(RateLimitMiddleware)
      .exclude('health', 'public', {
        path: 'metrics',
        method: RequestMethod.GET,
      })
      .forRoutes('*');

    consumer
      .apply(RateLimitMiddleware)
      .exclude('health', 'public')
      .forRoutes('*');

    consumer.apply(SessionMiddleware).forRoutes('auth/*');
  }
}


// common/errors/custom-errors.ts
export class AppError extends Error {
  constructor(
    public readonly message: string,
    public readonly code: string,
    public readonly httpStatus: number,
    public readonly details?: any,
    public readonly context?: string,
  ) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      error: this.name,
      message: this.message,
      code: this.code,
      details: this.details,
      context: this.context,
    };
  }
}

export class DatabaseError extends AppError {
  constructor(message: string, details?: any) {
    super(message, 'DATABASE_ERROR', 500, details);
  }
}

export class PasswordValidationError extends AppError {
  constructor(errors: string[]) {
    super(
      'Password validation failed',
      'PASSWORD_VALIDATION_ERROR',
      400,
      errors,
    );
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: any, context?: string) {
    super(message, 'VALIDATION_ERROR', 400, details, context);
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string, details?: any, context?: string) {
    super(message, 'AUTHENTICATION_ERROR', 401, details, context);
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string, details?: any, context?: string) {
    super(message, 'AUTHORIZATION_ERROR', 403, details, context);
  }
}

export class SessionError extends AppError {
  constructor(message: string, details?: any, context?: string) {
    super(message, 'SESSION_ERROR', 401, details, context);
  }
}

export class RateLimitError extends AppError {
  constructor(message: string, details?: any, context?: string) {
    super(message, 'RATE_LIMIT_ERROR', 429, details, context);
  }
}

export class TwoFactorError extends AppError {
  constructor(message: string, details?: any, context?: string) {
    super(message, 'TWO_FACTOR_ERROR', 401, details, context);
  }
}

export class AccountError extends AppError {
  constructor(message: string, details?: any, context?: string) {
    super(message, 'ACCOUNT_ERROR', 403, details, context);
  }
}


// common/errors/error-codes.ts
export const ErrorCodes = {
  AUTH: {
    INVALID_CREDENTIALS: 'AUTH_001',
    ACCOUNT_LOCKED: 'AUTH_002',
    SESSION_EXPIRED: 'AUTH_003',
    INVALID_TOKEN: 'AUTH_004',
    EMAIL_NOT_VERIFIED: 'AUTH_005',
    ACCOUNT_DEACTIVATED: 'AUTH_006',
    TWO_FACTOR_REQUIRED: 'AUTH_007',
    INVALID_2FA_TOKEN: 'AUTH_008',
    SESSION_LIMIT_EXCEEDED: 'AUTH_009',
    INVALID_RESET_TOKEN: 'AUTH_010',
  },
  VALIDATION: {
    INVALID_PASSWORD: 'VAL_001',
    INVALID_EMAIL: 'VAL_002',
    INVALID_USERNAME: 'VAL_003',
    PASSWORD_HISTORY: 'VAL_004',
    INVALID_INPUT: 'VAL_005',
  },
  DATABASE: {
    UNIQUE_CONSTRAINT: 'DB_001',
    RECORD_NOT_FOUND: 'DB_002',
    INVALID_DATA: 'DB_003',
    OPERATION_FAILED: 'DB_004',
    UNKNOWN_ERROR: 'DB_005',
  },
  RATE_LIMIT: {
    TOO_MANY_REQUESTS: 'RATE_001',
    TOO_MANY_FAILED_ATTEMPTS: 'RATE_002',
  },
  ACCOUNT: {
    ALREADY_EXISTS: 'ACC_001',
    NOT_FOUND: 'ACC_002',
    BLOCKED: 'ACC_003',
    SUSPENDED: 'ACC_004',
  },
} as const;

// Add error code type for better TypeScript support
export type ErrorCode =
  (typeof ErrorCodes)[keyof typeof ErrorCodes][keyof (typeof ErrorCodes)[keyof typeof ErrorCodes]];


// common/errors/error-handling.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { MetricsService } from '../monitoring/metrics.service';
import { ConfigService } from '@nestjs/config';
import {
  AppError,
  DatabaseError,
  SessionError,
  ValidationError,
} from './custom-errors';
import { ErrorCodes } from './error-codes';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';

@Injectable()
export class ErrorHandlingService {
  private readonly logger = new Logger(ErrorHandlingService.name);
  private readonly isDevelopment: boolean;

  constructor(
    private configService: ConfigService,
    private metricsService: MetricsService,
  ) {
    this.isDevelopment = configService.get('NODE_ENV') === 'development';
  }

  handleDatabaseError(error: Error, context: string): never {
    this.logError(error, context);
    this.metricsService.incrementCounter('database_errors');

    if (error instanceof PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          throw new DatabaseError('Unique constraint violation', {
            code: ErrorCodes.DATABASE.UNIQUE_CONSTRAINT,
            fields: error.meta?.target,
            context,
          });
        case 'P2025':
          throw new DatabaseError('Record not found', {
            code: ErrorCodes.DATABASE.RECORD_NOT_FOUND,
            context,
          });
        case 'P2014':
          throw new DatabaseError('Invalid data provided', {
            code: ErrorCodes.DATABASE.INVALID_DATA,
            context,
          });
        default:
          throw new DatabaseError('Database operation failed', {
            code: ErrorCodes.DATABASE.OPERATION_FAILED,
            context,
          });
      }
    }

    throw new DatabaseError('Unexpected database error', {
      code: ErrorCodes.DATABASE.UNKNOWN_ERROR,
      context,
    });
  }

  handleValidationError(error: Error, context: string): never {
    this.logError(error, context);
    this.metricsService.incrementCounter('validation_errors');

    throw new ValidationError('Validation failed', {
      code: ErrorCodes.VALIDATION.INVALID_INPUT,
      details: this.formatErrorDetails(error),
      context,
    });
  }

  handleSessionError(error: Error, context: string): never {
    this.logError(error, context);
    this.metricsService.incrementCounter('session_errors');

    throw new SessionError('Session error occurred', {
      code: ErrorCodes.AUTH.SESSION_EXPIRED,
      details: this.formatErrorDetails(error),
      context,
    });
  }

  handleAuthenticationError(error: Error, context: string): never {
    this.logError(error, context);
    this.metricsService.incrementCounter('authentication_errors');

    throw new AppError('Authentication failed', 'AUTH_ERROR', 401, {
      code: ErrorCodes.AUTH.INVALID_CREDENTIALS,
      details: this.formatErrorDetails(error),
      context,
    });
  }

  private formatErrorDetails(error: Error): any {
    if (!this.isDevelopment) {
      return undefined;
    }

    return {
      name: error.name,
      message: error.message,
      stack: error.stack,
    };
  }

  private logError(error: Error, context: string): void {
    this.logger.error(`Error in ${context}: ${error.message}`, error.stack, {
      errorName: error.name,
      timestamp: new Date().toISOString(),
      context,
    });
  }
}


// common/errors/error.module.ts
import { Global, Module } from '@nestjs/common';
import { ErrorHandlingService } from './error-handling.service';
import { MetricsService } from '../monitoring/metrics.service';

@Global()
@Module({
  providers: [ErrorHandlingService, MetricsService],
  exports: [ErrorHandlingService],
})
export class ErrorModule {}


// common/filters/global-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
  Inject,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { AppError } from '../errors/custom-errors';
import { MetricsService } from '../monitoring/metrics.service';
import { ErrorResponse } from '../interfaces/error-response.interface';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(GlobalExceptionFilter.name);

  constructor(@Inject(MetricsService) private metricsService: MetricsService) {}

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let errorResponse: ErrorResponse;

    if (exception instanceof AppError) {
      errorResponse = this.handleAppError(exception);
    } else if (exception instanceof HttpException) {
      errorResponse = this.handleHttpException(exception);
    } else {
      errorResponse = {
        code: 'INTERNAL_ERROR',
        message: 'Internal server error',
        timestamp: new Date().toISOString(),
        details: process.env.NODE_ENV === 'development' ? 
          { error: exception instanceof Error ? exception.message : 'Unknown error' } : 
          undefined
      };
    }

    errorResponse.path = request.url;

    // Log error
    this.logError(request, errorResponse, exception);

    // Track metrics
    this.trackErrorMetrics(Number(errorResponse.code), request.path);

    response
      .status(this.getHttpStatus(exception))
      .json(errorResponse);
  }

  private handleAppError(error: AppError) {
    return {
      code: error.code || 'UNKNOWN_ERROR',
      message: error.message,
      details: error.details,
      timestamp: new Date().toISOString()
    };
  }

  private handleHttpException(exception: HttpException): ErrorResponse {
    const response = exception.getResponse();
    return {
      code: exception instanceof AppError ? exception.code : 'HTTP_ERROR',
      message: typeof response === 'string' ? response : (response as any).message,
      details: typeof response === 'object' ? response : undefined,
      timestamp: new Date().toISOString()
    };
  }

  private getHttpStatus(exception: unknown): number {
    if (exception instanceof HttpException) {
      return exception.getStatus();
    }
    if (exception instanceof AppError) {
      return exception.httpStatus || 500;
    }
    return 500;
  }

  private handleUnknownError(error: Error) {
    return {
      statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
      message: 'Internal server error',
      code: 'INTERNAL_ERROR',
      details: error.message,
    };
  }

  private logError(
    request: Request,
    errorResponse: any,
    originalError: unknown,
  ) {
    this.logger.error(`${request.method} ${request.url}`, {
      error: errorResponse,
      stack: originalError instanceof Error ? originalError.stack : undefined,
      body: request.body,
      params: request.params,
      query: request.query,
      headers: this.sanitizeHeaders(request.headers),
    });
  }

  private sanitizeHeaders(headers: any) {
    const sanitized = { ...headers };
    delete sanitized.authorization;
    delete sanitized.cookie;
    return sanitized;
  }

  private trackErrorMetrics(statusCode: number, path: string) {
    this.metricsService.incrementCounter('errors_total', {
      status_code: statusCode,
      path: path,
    });
  }
}


// common/interfaces/error-response.interface.ts
export interface ErrorResponse {
    code: string;
    message: string;
    details?: Record<string, any>;
    timestamp: string;
    path?: string;
  }

// common/monitoring/logger.service.ts
import { ConsoleLogger, Injectable } from '@nestjs/common';
import * as winston from 'winston';
import 'winston-daily-rotate-file';

@Injectable()
export class CustomLoggerService extends ConsoleLogger {
  private winston: winston.Logger;

  constructor() {
    super();
    this.initializeWinston();
  }

  private initializeWinston() {
    const fileFormat = winston.format.combine(winston.format.json());

    this.winston = winston.createLogger({
      level: 'info',
      format: fileFormat,
      transports: [
        new winston.transports.DailyRotateFile({
          filename: 'logs/error-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          level: 'error',
          maxSize: '20m',
          maxFiles: '14d',
        }),
        new winston.transports.DailyRotateFile({
          filename: 'logs/combined-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          maxSize: '20m',
          maxFiles: '14d',
        }),
      ],
    });

    if (process.env.NODE_ENV !== 'production') {
      this.winston.add(
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple(),
          ),
        }),
      );
    }
  }

  log(message: any, context?: string) {
    this.winston.info(message, { context });
    super.log(message, context);
  }

  error(message: any, stack?: string, context?: string) {
    this.winston.error(message, { stack, context });
    super.error(message, stack, context);
  }

  warn(message: any, context?: string) {
    this.winston.warn(message, { context });
    super.warn(message, context);
  }

  debug(message: any, context?: string) {
    this.winston.debug(message, { context });
    super.debug(message, context);
  }

  verbose(message: any, context?: string) {
    this.winston.verbose(message, { context });
    super.verbose(message, context);
  }
}


// common/monitoring/metrics.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as promClient from 'prom-client';

interface MetricLabels {
  [key: string]: string | number;
}

@Injectable()
export class MetricsService implements OnModuleInit {
  private static instance: MetricsService | null = null;
  private readonly register: promClient.Registry;
  private httpRequestDuration: promClient.Histogram;
  private httpRequestTotal: promClient.Counter;
  private errorCounter: promClient.Counter;
  private customCounters: Map<string, promClient.Counter> = new Map();

  constructor(private config: ConfigService) {
    if (!MetricsService.instance) {
      this.register = new promClient.Registry();
      promClient.collectDefaultMetrics({ register: this.register });
      MetricsService.instance = this;
    }
    return MetricsService.instance;
  }

  onModuleInit() {
    if (!this.httpRequestDuration) {
      this.initializeMetrics();
    }
  }

  private initializeMetrics() {
    try {
      // Initialize error counter
      this.errorCounter = new promClient.Counter({
        name: 'app_errors_total',
        help: 'Total number of errors by type',
        labelNames: ['error_type', 'path', 'status_code'],
        registers: [this.register],
      });

      this.httpRequestDuration = new promClient.Histogram({
        name: 'http_request_duration_seconds',
        help: 'Duration of HTTP requests in seconds',
        labelNames: ['method', 'route', 'status_code'],
        buckets: [0.1, 0.5, 1, 2, 5],
        registers: [this.register],
      });

      this.httpRequestTotal = new promClient.Counter({
        name: 'http_requests_total',
        help: 'Total number of HTTP requests',
        labelNames: ['method', 'route', 'status_code'],
        registers: [this.register],
      });
    } catch (error) {
      // Log error but don't throw to prevent app crash
      console.error('Error initializing metrics:', error);
    }
  }

  private getOrCreateCounter(
    name: string,
    labels?: string[],
  ): promClient.Counter {
    const counterName = `app_${name}_total`;

    if (!this.customCounters.has(counterName)) {
      try {
        const counter = new promClient.Counter({
          name: counterName,
          help: `Total number of ${name}`,
          labelNames: labels || [],
          registers: [this.register],
        });
        this.customCounters.set(counterName, counter);
      } catch (error) {
        // If counter already exists, try to get it from the registry
        const existingCounter = this.register.getSingleMetric(counterName);
        if (existingCounter) {
          this.customCounters.set(
            counterName,
            existingCounter as promClient.Counter,
          );
        } else {
          console.error(`Error creating counter ${counterName}:`, error);
        }
      }
    }

    return this.customCounters.get(counterName);
  }

  incrementCounter(name: string, labels?: MetricLabels) {
    try {
      const counter = this.getOrCreateCounter(
        name,
        labels ? Object.keys(labels) : undefined,
      );

      if (counter) {
        if (labels) {
          counter.inc(labels);
        } else {
          counter.inc();
        }
      }
    } catch (error) {
      console.error(`Error incrementing counter ${name}:`, error);
    }
  }

  recordHttpRequest(
    method: string,
    route: string,
    statusCode: number,
    duration: number,
  ) {
    try {
      if (this.httpRequestDuration) {
        this.httpRequestDuration
          .labels(method, route, statusCode.toString())
          .observe(duration);
      }
      if (this.httpRequestTotal) {
        this.httpRequestTotal
          .labels(method, route, statusCode.toString())
          .inc();
      }
    } catch (error) {
      console.error('Error recording HTTP request:', error);
    }
  }

  async getMetrics(): Promise<string> {
    return this.register.metrics();
  }

  clearRegistry() {
    this.register.clear();
  }
}


// common/monitoring/monitoring.module.ts
import { Global, Module } from '@nestjs/common';
import { PerformanceService } from './performance.service';
import { CustomLoggerService } from './logger.service';
import { MetricsService } from './metrics.service';
import { ConfigService } from '@nestjs/config';

@Global()
@Module({
  providers: [
    {
      provide: MetricsService,
      useFactory: (config: ConfigService) => {
        return new MetricsService(config);
      },
      inject: [ConfigService],
    },
    PerformanceService,
    CustomLoggerService,
    {
      provide: 'Logger',
      useClass: CustomLoggerService,
    },
  ],
  exports: [MetricsService, PerformanceService, CustomLoggerService, 'Logger'],
})
export class MonitoringModule {}


// common/monitoring/performance.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { performance } from 'perf_hooks';

@Injectable()
export class PerformanceService {
  private readonly logger = new Logger('Performance');
  private metrics: Map<string, number[]> = new Map();
  private counters: Map<string, number> = new Map();
  private gauges: Map<string, number> = new Map();

  trackMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name).push(value);
  }

  async measureAsync<T>(name: string, operation: () => Promise<T>): Promise<T> {
    const start = performance.now();
    try {
      const result = await operation();
      const duration = performance.now() - start;
      this.trackMetric(name, duration);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      this.trackMetric(`${name}_error`, duration);
      throw error;
    }
  }

  private calculatePercentile(values: number[], percentile: number): number {
    const sorted = [...values].sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }

  getMetricsSummary() {
    const summary = {
      timers: {},
      counters: {},
      gauges: {},
    };

    // Process timers
    this.metrics.forEach((values, name) => {
      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      summary.timers[name] = {
        average: avg.toFixed(2),
        min: Math.min(...values).toFixed(2),
        max: Math.max(...values).toFixed(2),
        count: values.length,
        p95: this.calculatePercentile(values, 95).toFixed(2),
      };
    });

    // Add counters and gauges
    summary.counters = Object.fromEntries(this.counters);
    summary.gauges = Object.fromEntries(this.gauges);

    return summary;
  }

  incrementCounter(name: string) {
    const current = this.counters.get(name) || 0;
    this.counters.set(name, current + 1);
  }

  setGauge(name: string, value: number) {
    this.gauges.set(name, value);
  }

  clearMetrics() {
    this.metrics.clear();
  }
}


// common/security/request-sanitizer.middleware.spec.ts
import { RequestSanitizerMiddleware } from './request-sanitizer.middleware';
import { Request, Response } from 'express';

describe('RequestSanitizerMiddleware', () => {
  let middleware: RequestSanitizerMiddleware;

  beforeEach(() => {
    middleware = new RequestSanitizerMiddleware();
  });

  it('should sanitize body data', () => {
    const req = {
      body: {
        text: '<script>alert("xss")</script>Hello',
        nested: {
          text: '<img src="x" onerror="alert(1)">World',
        },
      },
    } as Request;

    const res = {} as Response;
    const next = jest.fn();

    middleware.use(req, res, next);

    expect(req.body.text).toBe('Hello');
    expect(req.body.nested.text).toBe('World');
    expect(next).toHaveBeenCalled();
  });

  it('should handle non-string values', () => {
    const req = {
      body: {
        number: 123,
        boolean: true,
        null: null,
        undefined: undefined,
      },
    } as Request;

    const res = {} as Response;
    const next = jest.fn();

    middleware.use(req, res, next);

    expect(req.body).toEqual({
      number: 123,
      boolean: true,
      null: null,
      undefined: undefined,
    });
    expect(next).toHaveBeenCalled();
  });

  it('should handle complex HTML payloads', () => {
    const req = {
      body: {
        text: `<div class="dangerous">
          <script>alert('xss')</script>
          <p onclick="evil()">Hello</p>
          <iframe src="evil.com"></iframe>
          World
        </div>`,
      },
    } as Request;

    const res = {} as Response;
    const next = jest.fn();

    middleware.use(req, res, next);

    expect(req.body.text.trim()).toBe('Hello World');
    expect(next).toHaveBeenCalled();
  });

  it('should preserve safe strings', () => {
    const req = {
      body: {
        text: 'This is a safe string without any HTML',
      },
    } as Request;

    const res = {} as Response;
    const next = jest.fn();

    middleware.use(req, res, next);

    expect(req.body.text).toBe('This is a safe string without any HTML');
    expect(next).toHaveBeenCalled();
  });
});


// common/security/request-sanitizer.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import * as sanitizeHtml from 'sanitize-html';

@Injectable()
export class RequestSanitizerMiddleware implements NestMiddleware {
  private readonly sanitizeOptions: sanitizeHtml.IOptions = {
    allowedTags: [],
    allowedAttributes: {},
    disallowedTagsMode: 'discard' as sanitizeHtml.DisallowedTagsModes,
    textFilter: (text) => {
      // Remove any remaining HTML entities
      return text.replace(/&[^;]+;/g, '');
    },
  };

  use(req: Request, res: Response, next: NextFunction) {
    if (req.body) {
      this.sanitizeObject(req.body);
    }

    if (req.query) {
      this.sanitizeObject(req.query);
    }

    if (req.params) {
      this.sanitizeObject(req.params);
    }

    next();
  }

  private sanitizeObject(obj: any) {
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] === 'string') {
        obj[key] = this.sanitizeInput(obj[key]);
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        this.sanitizeObject(obj[key]);
      }
    });
  }

  private sanitizeInput(input: string): string {
    const sanitized = sanitizeHtml(input, this.sanitizeOptions);
    return sanitized
      .replace(/&[^;]+;/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  }
}


// common/security/security-headers.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import helmet from 'helmet';

@Injectable()
export class SecurityHeadersMiddleware implements NestMiddleware {
  private readonly helmetMiddleware: any;

  constructor() {
    this.helmetMiddleware = helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", 'data:', 'https:'],
          connectSrc: ["'self'"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      },
      crossOriginEmbedderPolicy: true,
      crossOriginOpenerPolicy: true,
      crossOriginResourcePolicy: { policy: 'same-origin' },
      dnsPrefetchControl: true,
      frameguard: { action: 'deny' },
      hidePoweredBy: true,
      hsts: true,
      ieNoOpen: true,
      noSniff: true,
      referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
      xssFilter: true,
    });
  }

  use(req: Request, res: Response, next: NextFunction) {
    this.helmetMiddleware(req, res, next);
  }
}


// config/configuration.ts
/**
 * Application configuration object.
 * @returns {Object} Configuration object with various settings
 */
export default () => ({
  port: parseInt(process.env.PORT, 10) || 3000,
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
  },
  email: {
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT, 10) || 587,
    user: process.env.EMAIL_USER,
    password: process.env.EMAIL_PASSWORD,
  },
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY,
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
  },
});


// health/health.controller.ts
import { Controller, Get, Logger } from '@nestjs/common';
import { HealthService } from './health.service';
import { HealthStatus } from './types';

@Controller('health')
export class HealthController {
  private readonly logger = new Logger(HealthController.name);

  constructor(private healthService: HealthService) {}

  @Get()
  async check(): Promise<
    HealthStatus | { status: 'error'; error: string; timestamp: string }
  > {
    try {
      const healthCheck = await this.healthService.checkHealth();
      this.logger.debug('Health check completed', healthCheck);
      return healthCheck;
    } catch (error) {
      this.logger.error('Health check failed', error.stack);
      return {
        status: 'error',
        error: error.message,
        timestamp: new Date().toISOString(),
      };
    }
  }
}


// health/health.module.ts
import { Module } from '@nestjs/common';
import { HealthController } from './health.controller';
import { HealthService } from './health.service';
import { PrismaModule } from '../prisma/prisma.module';
import { RedisModule } from '../redis/redis.module';

@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [HealthController],
  providers: [HealthService],
  exports: [HealthService],
})
export class HealthModule {}


// health/health.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService } from '../redis/redis.service';
import { HealthCheckResult, HealthStatus, MemoryHealthCheck } from './types';

@Injectable()
export class HealthService {
  private readonly logger = new Logger(HealthService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  async checkHealth(): Promise<HealthStatus> {
    const checks = {
      database: await this.checkDatabase(),
      redis: await this.checkRedis(),
      memory: this.checkMemory(),
      uptime: process.uptime(),
    };

    return {
      status: this.determineOverallStatus(checks),
      checks,
      timestamp: new Date().toISOString(),
    };
  }

  private determineOverallStatus(checks: {
    database: HealthCheckResult;
    redis: HealthCheckResult;
    memory: MemoryHealthCheck;
    uptime: number;
  }): 'ok' | 'error' {
    const statuses = [checks.database, checks.redis, checks.memory];
    return statuses.every((check) => check.status === 'ok') ? 'ok' : 'error';
  }

  private async checkDatabase(): Promise<HealthCheckResult> {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return { status: 'ok' };
    } catch (error) {
      this.logger.error('Database health check failed', error.stack);
      return { status: 'error', error: error.message };
    }
  }

  private async checkRedis(): Promise<HealthCheckResult> {
    try {
      await this.redis.set('health-check', 'ok', 10);
      await this.redis.get('health-check');
      return { status: 'ok' };
    } catch (error) {
      this.logger.error('Redis health check failed', error.stack);
      return { status: 'error', error: error.message };
    }
  }

  private checkMemory(): MemoryHealthCheck {
    const used = process.memoryUsage();
    return {
      status: 'ok',
      heap: Math.round(used.heapUsed / 1024 / 1024),
      rss: Math.round(used.rss / 1024 / 1024),
    };
  }
}


// health/types.ts
export interface HealthCheckResult {
  status: 'ok' | 'error';
  error?: string;
}

export interface MemoryHealthCheck {
  status: 'ok';
  heap: number;
  rss: number;
}

export interface HealthStatus {
  status: 'ok' | 'error';
  checks: {
    database: HealthCheckResult;
    redis: HealthCheckResult;
    memory: MemoryHealthCheck;
    uptime: number;
  };
  timestamp: string;
}


// main.ts
// server/src/main.ts

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe, Logger } from '@nestjs/common';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';
import { CustomLoggerService } from './common/monitoring/logger.service';
import { MetricsService } from './common/monitoring/metrics.service';

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule, {
    logger: new CustomLoggerService(),
  });

  const metricsService = app.get(MetricsService);

  app.enableCors({
    origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
    credentials: true,
  });

  app.useGlobalFilters(new GlobalExceptionFilter(metricsService));
  app.useLogger(new CustomLoggerService());

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
      disableErrorMessages: process.env.NODE_ENV === 'production',
    }),
  );

  const port = process.env.PORT || 5000;
  const host = process.env.HOST || '0.0.0.0';
  await app.listen(port, host);
  logger.log(`Application is running on: http://localhost:${port}`);
}
bootstrap();


// modules/auth/auth.controller.ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Req,
  UnauthorizedException,
  UseGuards,
  Headers,
  HttpCode,
  HttpStatus,
  BadRequestException,
} from '@nestjs/common';
import { Request } from 'express';
import { AuthService } from './services/auth.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { RequestResetDto, ResetPasswordDto } from './dto/password-reset.dto';
import { Throttle } from '@nestjs/throttler';
import { JwtAuthGuard } from './guard/jwt-auth.guard';
import { SessionService } from './services/session.service';
import { SessionGuard } from './guard/session.guard';
import { PerformanceService } from 'src/common/monitoring/performance.service';
import { ResendVerificationDto, VerifyEmailDto } from './dto/verifiy-email.dto';
import { DeviceService } from './services/device.service';
import { Enable2FADto, Verify2FADto } from './dto/2fa.dto';
import { TwoFactorService } from './services/two-factor.service';
import { LocationService } from './services/location.service';

@Controller('auth')
export class AuthController {
  constructor(
    private authService: AuthService,
    private sessionService: SessionService,
    private performanceService: PerformanceService,
    private deviceService: DeviceService,
    private twoFactorService: TwoFactorService,
    private locationService: LocationService,
  ) {}

  @Get('devices')
  @UseGuards(JwtAuthGuard)
  async getUserDevices(@Req() req: Request & { user: any }) {
    return this.deviceService.getUserDevices(req.user.id);
  }

  @Post('devices/:deviceId/trust')
  @UseGuards(JwtAuthGuard)
  async trustDevice(
    @Param('deviceId') deviceId: string,
    @Req() req: Request & { user: any },
  ) {
    await this.deviceService.setDeviceTrusted(deviceId, req.user.id, true);
    return { message: 'Device trusted successfully' };
  }

  @Delete('devices/:deviceId')
  @UseGuards(JwtAuthGuard)
  async removeDevice(
    @Param('deviceId') deviceId: string,
    @Headers('session-id') currentSessionId: string,
    @Req() req: Request & { user: any },
  ) {
    // Check if trying to remove current device
    const currentSession =
      await this.sessionService.getSession(currentSessionId);
    if (currentSession?.deviceId === deviceId) {
      throw new BadRequestException('Cannot remove currently active device');
    }

    await this.deviceService.removeDevice(deviceId, req.user.id);
    const revokedSessions = await this.sessionService.revokeDeviceSessions(
      req.user.id,
      deviceId,
    );

    return {
      message: 'Device removed successfully',
      sessionsRevoked: revokedSessions,
    };
  }

  @Get('metrics')
  @UseGuards(JwtAuthGuard)
  async getMetrics() {
    const metrics = this.performanceService.getMetricsSummary();
    return {
      metrics,
      timestamp: new Date().toISOString(),
    };
  }

  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  @Throttle({ default: { limit: 5, ttl: 60000 } })
  async login(
    @Body() loginDto: LoginDto,
    @Req() request: Request,
    @Body('forceLogout') forceLogout?: boolean,
  ) {
    return this.authService.login({
      loginDto,
      ipAddress: request.ip,
      userAgent: request.headers['user-agent'] || 'unknown',
      sessionOptions: {
        forceLogoutOthers: forceLogout,
        maxSessions: 5,
      },
    });
  }

  @Post('sessions/cleanup')
  @UseGuards(JwtAuthGuard)
  async cleanupOldSessions(
    @Req() req: Request & { user: any },
    @Body('maxAgeDays') maxAgeDays?: number,
  ) {
    const cleanedCount = await this.sessionService.cleanupOldSessions(
      req.user.id,
      maxAgeDays,
    );
    return {
      message: `Cleaned up ${cleanedCount} old sessions`,
      remainingSessions: await this.sessionService.getUserSessions(req.user.id),
    };
  }

  @Delete('sessions/others')
  @UseGuards(JwtAuthGuard)
  async logoutOtherSessions(
    @Req() req: Request & { user: any },
    @Headers('session-id') currentSessionId: string,
  ) {
    const logoutCount = await this.sessionService.forceLogoutOtherSessions(
      req.user.id,
      currentSessionId,
    );
    return {
      message: `Logged out from ${logoutCount} other sessions`,
      currentSession: currentSessionId,
    };
  }

  @Post('logout')
  @HttpCode(HttpStatus.OK)
  @UseGuards(JwtAuthGuard, SessionGuard)
  async logout(@Headers('session-id') sessionId: string) {
    return this.authService.logout(sessionId);
  }

  @Post('password-reset/request')
  @HttpCode(HttpStatus.OK)
  @Throttle({ default: { limit: 3, ttl: 300000 } })
  async requestPasswordReset(@Body() resetDto: RequestResetDto) {
    return this.authService.requestPasswordReset(resetDto.email);
  }

  @Post('password-reset/reset')
  @HttpCode(HttpStatus.OK)
  async resetPassword(@Body() resetDto: ResetPasswordDto) {
    return this.authService.resetPassword(resetDto);
  }

  @Get('sessions')
  @UseGuards(JwtAuthGuard)
  async getSessions(@Req() req: Request & { user: any }) {
    const sessions = await this.sessionService.getUserSessions(req.user.id);
    return { sessions };
  }

  @Delete('sessions/:sessionId')
  @HttpCode(HttpStatus.OK)
  @UseGuards(JwtAuthGuard)
  async terminateSession(
    @Param('sessionId') sessionId: string,
    @Req() req: Request & { user: any },
  ) {
    const session = await this.sessionService.getSession(sessionId);
    if (!session) {
      throw new UnauthorizedException('Session not found');
    }

    if (session.userId !== req.user.id) {
      throw new UnauthorizedException('Unauthorized to terminate this session');
    }

    await this.sessionService.destroySession(sessionId);
    return { message: 'Session terminated successfully' };
  }

  @Delete('logout-all')
  @HttpCode(HttpStatus.OK)
  @UseGuards(JwtAuthGuard)
  async terminateAllSessions(
    @Headers('session-id') currentSessionId: string,
    @Req() req: Request & { user: any },
    @Body() body: { keepCurrentSession?: boolean },
  ) {
    const result = await this.authService.logoutAllDevices(
      req.user.id,
      body.keepCurrentSession ? currentSessionId : undefined,
    );
    return result;
  }

  @Post('extend-session')
  @UseGuards(JwtAuthGuard, SessionGuard)
  async extendUserSession(
    @Headers('session-id') sessionId: string,
    @Body() body: { duration?: number },
  ) {
    await this.sessionService.extendSession(sessionId, body.duration);
    return { message: 'Session extended successfully' };
  }

  @Post('block')
  @HttpCode(HttpStatus.OK)
  @UseGuards(JwtAuthGuard)
  async blockUser(
    @Headers('session-id') currentSessionId: string,
    @Req() req: Request & { user: any },
    @Body() blockAccountId: string,
  ) {
    return this.authService.blockAccount(blockAccountId);
  }

  @Post('verify-email')
  @HttpCode(HttpStatus.OK)
  async verifyEmail(@Body() verifyEmailDto: VerifyEmailDto) {
    return this.authService.verifyEmail(verifyEmailDto.token);
  }

  @Post('resend-verification')
  @HttpCode(HttpStatus.OK)
  async resendVerification(@Body() resendDto: ResendVerificationDto) {
    return this.authService.resendVerificationEmail(resendDto.email);
  }

  @Get('me')
  @UseGuards(JwtAuthGuard)
  async getCurrentUser(@Req() req: Request & { user: any }) {
    const { ...user } = req.user;
    user.password = '********';
    return user;
  }

  @Post('2fa/setup')
  @UseGuards(JwtAuthGuard)
  async setup2FA(@Req() req: Request & { user: any }) {
    return this.twoFactorService.generateSecret(req.user.id);
  }

  @Post('2fa/enable')
  @UseGuards(JwtAuthGuard)
  async enable2FA(
    @Req() req: Request & { user: any },
    @Body() body: Enable2FADto,
  ) {
    const isValid = await this.twoFactorService.verifyToken(
      req.user.id,
      body.token,
    );
    if (!isValid) {
      throw new UnauthorizedException('Invalid 2FA token');
    }
    await this.twoFactorService.enable2FA(req.user.id);
    return { message: '2FA enabled successfully' };
  }

  @Post('2fa/verify')
  @UseGuards(JwtAuthGuard)
  async verify2FA(
    @Req() req: Request & { user: any },
    @Body() body: Verify2FADto,
  ) {
    const isValid = await this.twoFactorService.verifyToken(
      req.user.id,
      body.token,
    );
    if (!isValid) {
      throw new UnauthorizedException('Invalid 2FA token');
    }
    return { message: '2FA verification successful' };
  }

  @Post('2fa/disable')
  @UseGuards(JwtAuthGuard)
  async disable2FA(@Req() req: Request & { user: any }) {
    await this.twoFactorService.disable2FA(req.user.id);
    return { message: '2FA disabled successfully' };
  }
}


// modules/auth/auth.request.http
### Authentication API Collection
@baseUrl = http://localhost:5000
@authToken = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjhhNTU1MS1jMzMzLTQ5ZjUtYWU3ZC04MGU1NTdjOTllODUiLCJ1c2VybmFtZSI6InRlc3R1c2VyIiwiZW1haWwiOiJ0ZXN0dXNlckBleGFtcGxlLmNvbSIsImlhdCI6MTczNDM3Mjk4NCwiZXhwIjoxNzM0OTc3Nzg0LCJhdWQiOiJuaWJibGl4LWNsaWVudHMiLCJpc3MiOiJuaWJibGl4LmNvbSJ9.2WkHYZ_sfIHGpSKB0lO2G4fhN-lkane-zcb4e0zMLOU
@sessionId = YOUR_SESSION_ID
@emailToken = a9999da7-7355-4c56-8aa6-400860a2d212

### Register a new user
POST {{baseUrl}}/auth/register
Content-Type: application/json

{
    "email": "testuser@example.com",
    "username": "testuser",
    "password": "daioUbdap09-0d0@dfa",
    "firstName": "Test",
    "lastName": "User"
}

### Login
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
    "username": "testuser",
    "password": "daioUbdap09-0d0@dfa"
}

### Get Current User
GET {{baseUrl}}/auth/me
Authorization: Bearer {{authToken}}

### Verify Email
POST {{baseUrl}}/auth/verify-email
Content-Type: application/json

{
    "token": "{{emailToken}}"
}

### Resend Verification Email
POST {{baseUrl}}/auth/resend-verification
Content-Type: application/json

{
    "email": "test@example.com"
}

### Request Password Reset
POST {{baseUrl}}/auth/password-reset/request
Content-Type: application/json

{
    "email": "test@example.com"
}

### Reset Password
POST {{baseUrl}}/auth/password-reset/reset
Content-Type: application/json

{
    "token": "TOKEN_FROM_EMAIL",
    "password": "NewPassword123!"
}

### Logout
POST {{baseUrl}}/auth/logout
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

### Logout from all devices
DELETE {{baseUrl}}/auth/logout-all
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

{
    "keepCurrentSession": true
}

### Get User Sessions
GET {{baseUrl}}/auth/sessions
Authorization: Bearer {{authToken}}

### Terminate Specific Session
DELETE {{baseUrl}}/auth/sessions/SESSION_ID
Authorization: Bearer {{authToken}}

### Extend Session
POST {{baseUrl}}/auth/extend-session
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

{
    "duration": 3600
}

### Get User Devices
GET {{baseUrl}}/auth/devices
Authorization: Bearer {{authToken}}

### Trust Device
POST {{baseUrl}}/auth/devices/DEVICE_ID/trust
Authorization: Bearer {{authToken}}

### Remove Device
DELETE {{baseUrl}}/auth/devices/DEVICE_ID
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

### Get Performance Metrics
GET {{baseUrl}}/auth/metrics
Authorization: Bearer {{authToken}}

### Block Account
POST {{baseUrl}}/auth/block
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

{
    "blockAccountId": "USER_ID_TO_BLOCK"
}


// modules/auth/dto/2fa.dto.ts
import { IsString, IsNotEmpty } from 'class-validator';

export class Enable2FADto {
  @IsString()
  @IsNotEmpty()
  token: string;
}

export class Verify2FADto {
  @IsString()
  @IsNotEmpty()
  token: string;
}


// modules/auth/dto/login.dto.ts
import { IsString, Matches, MaxLength, MinLength } from 'class-validator';

export class LoginDto {
  @IsString()
  @MinLength(3)
  @MaxLength(50)
  @Matches(/^[a-zA-Z0-9_-]+$/, {
    message:
      'Username can only contain letters, numbers, underscores and hyphens',
  })
  username: string;

  @IsString()
  @MinLength(6)
  password: string;
}


// modules/auth/dto/password-reset.dto.ts
import { IsEmail, IsString, MinLength, Matches } from 'class-validator';

export class RequestResetDto {
  @IsEmail()
  email: string;
}

export class ResetPasswordDto {
  @IsString()
  token: string;

  @IsString()
  @MinLength(8)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message:
      'Password must contain uppercase, lowercase, number and special character',
  })
  password: string;
}


// modules/auth/dto/register.dto.ts
import {
  IsEmail,
  IsString,
  MinLength,
  IsOptional,
  IsDate,
} from 'class-validator';
import { Type } from 'class-transformer';

export class RegisterDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(3)
  username: string;

  @IsString()
  @MinLength(8)
  password: string;

  @IsString()
  @IsOptional()
  firstName?: string;

  @IsString()
  @IsOptional()
  lastName?: string;

  @IsDate()
  @IsOptional()
  @Type(() => Date)
  birthDate?: Date;
}


// modules/auth/dto/verifiy-email.dto.ts
import { IsString, IsNotEmpty } from 'class-validator';

export class VerifyEmailDto {
  @IsString()
  @IsNotEmpty()
  token: string;
}

export class ResendVerificationDto {
  @IsString()
  @IsNotEmpty()
  email: string;
}


// modules/auth/guard/jwt-auth.guard.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}


// modules/auth/guard/session.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { SessionService } from '../services/session.service';

@Injectable()
export class SessionGuard implements CanActivate {
  constructor(private sessionService: SessionService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const sessionId = request.headers['session-id'];

    if (!sessionId) {
      throw new UnauthorizedException('No session provided');
    }

    const session = await this.sessionService.getSession(sessionId);
    if (!session) {
      throw new UnauthorizedException('Invalid session');
    }

    request.session = session;
    return true;
  }
}


// modules/auth/middleware/middleware.module.ts
import { Module } from '@nestjs/common';
import { RedisModule } from 'src/redis/redis.module';
import { DeviceModule } from '../module/device.module';
import { MonitoringModule } from 'src/common/monitoring/monitoring.module';
import { ErrorModule } from 'src/common/errors/error.module';
import { SessionMiddleware } from './session.middleware';
import { RateLimitMiddleware } from './rate-limit.middleware';
import { RequestLoggerMiddleware } from './request-logger.middleware';
import { SessionService } from '../services/session.service';

@Module({
  imports: [RedisModule, DeviceModule, ErrorModule, MonitoringModule],
  providers: [
    SessionMiddleware,
    RateLimitMiddleware,
    RequestLoggerMiddleware,
    SessionService,
  ],
  exports: [SessionMiddleware, RateLimitMiddleware, RequestLoggerMiddleware],
})
export class MiddlewareModule {}


// modules/auth/middleware/rate-limit.middleware.ts
import {
  Injectable,
  NestMiddleware,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { RedisService } from 'src/redis/redis.service';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class RateLimitMiddleware implements NestMiddleware {
  private readonly logger = new Logger(RateLimitMiddleware.name);

  private readonly defaultLimits = {
    'auth/login': { limit: 5, windowSize: 300 },
    'auth/register': { limit: 3, windowSize: 3600 },
    'auth/password-reset': { limit: 3, windowSize: 3600 },
    default: { limit: 100, windowSize: 900 },
  };

  constructor(
    private readonly redisService: RedisService,
    private readonly configService: ConfigService,
  ) {}

  private async getRateLimitData(
    key: string,
  ): Promise<{ count: number; ttl: number }> {
    const current = await this.redisService.get(key);
    const ttl = await this.redisService.ttl(key);
    return {
      count: current ? parseInt(current) : 0,
      ttl: ttl,
    };
  }

  private getLimitConfig(path: string): { limit: number; windowSize: number } {
    for (const [pattern, config] of Object.entries(this.defaultLimits)) {
      if (path.includes(pattern)) {
        return config;
      }
    }
    return this.defaultLimits.default;
  }

  private async checkRateLimit(
    key: string,
    config: { limit: number; windowSize: number },
    rateLimitData?: { count: number; ttl: number },
  ): Promise<{ count: number; ttl: number }> {
    const data = rateLimitData || (await this.getRateLimitData(key));
    const { count, ttl } = data;

    if (count >= config.limit) {
      const resetTime = new Date(
        Date.now() + Math.max(0, ttl) * 1000,
      ).toISOString();
      throw new HttpException(
        {
          statusCode: HttpStatus.TOO_MANY_REQUESTS,
          error: 'Too Many Requests',
          message: `Rate limit exceeded. Try again after ${resetTime}`,
          resetTime,
        },
        HttpStatus.TOO_MANY_REQUESTS,
      );
    }

    if (count === 0) {
      await this.redisService.set(key, '1', config.windowSize);
      return { count: 1, ttl: config.windowSize };
    } else {
      const newTtl = Math.max(1, ttl);
      await this.redisService.set(key, (count + 1).toString(), newTtl);
      return { count: count + 1, ttl: newTtl };
    }
  }

  private async addRateLimitHeaders(
    res: Response,
    key: string,
    config: { limit: number; windowSize: number },
    rateLimitData: { count: number; ttl: number },
  ): Promise<void> {
    try {
      const resetTime = new Date(
        Date.now() +
          (Number.isFinite(rateLimitData.ttl) && rateLimitData.ttl > 0
            ? rateLimitData.ttl
            : config.windowSize) *
            1000,
      );

      res.setHeader('X-RateLimit-Limit', config.limit);
      res.setHeader(
        'X-RateLimit-Remaining',
        Math.max(0, config.limit - rateLimitData.count),
      );
      res.setHeader('X-RateLimit-Reset', resetTime.toISOString());
    } catch (error) {
      this.logger.error(`Error setting rate limit headers: ${error.message}`);
    }
  }

  private async getCurrentCount(key: string): Promise<number> {
    const current = await this.redisService.get(key);
    return current ? parseInt(current) : 0;
  }

  async use(req: Request, res: Response, next: NextFunction) {
    try {
      const ip = req.ip;
      const path = req.path.toLowerCase();
      const userId = (req as any).user?.id;

      const config = this.getLimitConfig(path);

      const ipKey = `rateLimit:${ip}:${path}`;
      const userKey = userId ? `rateLimit:user:${userId}:${path}` : null;

      // Check IP-based rate limit
      const ipLimitData = await this.checkRateLimit(ipKey, config);

      // Check user-based rate limit if authenticated
      if (userKey) {
        await this.checkRateLimit(userKey, config);
      }

      // Add rate limit headers based on IP limit
      await this.addRateLimitHeaders(res, ipKey, config, ipLimitData);

      next();
    } catch (error) {
      if (error instanceof HttpException) {
        throw error;
      }
      this.logger.error(`Rate limit error: ${error.message}`, error.stack);
      throw new HttpException(
        'Rate limit error occurred',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}


// modules/auth/middleware/request-logger.middleware.ts
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class RequestLoggerMiddleware implements NestMiddleware {
  private logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction) {
    const { ip, method, originalUrl } = req;
    const userAgent = req.get('user-agent') || '';

    res.on('finish', () => {
      const { statusCode } = res;
      const contentLength = res.get('content-length');

      this.logger.log(
        `${method} ${originalUrl} ${statusCode} ${contentLength} - ${userAgent} ${ip}`,
      );
    });

    next();
  }
}


// modules/auth/middleware/session.middleware.ts
import {
  Injectable,
  NestMiddleware,
  UnauthorizedException,
} from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { SessionService } from '../services/session.service';

@Injectable()
export class SessionMiddleware implements NestMiddleware {
  constructor(private readonly sessionService: SessionService) {}

  async use(req: Request, res: Response, next: NextFunction) {
    const sessionId = req.headers['session-id'] as string;

    if (!sessionId) {
      return next();
    }

    const session = await this.sessionService.getSession(sessionId);
    if (!session) {
      throw new UnauthorizedException('Invalid session');
    }

    req['session'] = session;
    next();
  }
}


// modules/auth/module/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { AuthController } from '../auth.controller';
import { AuthService } from '../services/auth.service';
import { JwtStrategy } from '../strategies/jwt.strategy';
import { PrismaService } from '../../../prisma/prisma.service';
import { RedisModule } from 'src/redis/redis.module';
import { SessionService } from '../services/session.service';
import { MailModule } from '../../mail/mail.module';
import { PerformanceService } from 'src/common/monitoring/performance.service';
import { DeviceService } from '../services/device.service';
import { DeviceModule } from './device.module';
import { TwoFactorService } from '../services/two-factor.service';
import { LocationService } from '../services/location.service';
import { PasswordService } from '../services/password.service';

@Module({
  imports: [
    RedisModule,
    MailModule,
    DeviceModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: {
        expiresIn: process.env.JWT_EXPIRES_IN || '1d',
        issuer: 'nibblix.com',
        audience: 'nibblix-clients',
      },
    }),
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    JwtStrategy,
    PrismaService,
    SessionService,
    PerformanceService,
    DeviceService,
    LocationService,
    TwoFactorService,
    PasswordService,
  ],
  exports: [AuthService, SessionService, DeviceService, PasswordService],
})
export class AuthModule {}


// modules/auth/module/device.module.ts
import { Module } from '@nestjs/common';
import { DeviceService } from '../services/device.service';
import { PrismaModule } from '../../../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [DeviceService],
  exports: [DeviceService],
})
export class DeviceModule {}


// modules/auth/services/auth.service.ts
import { Injectable, UnauthorizedException, Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as crypto from 'crypto';
import { PrismaService } from '../../../prisma/prisma.service';
import { LoginDto } from '../dto/login.dto';
import { RegisterDto } from '../dto/register.dto';
import * as bcrypt from 'bcryptjs';
import { SessionService } from './session.service';
import { RedisService } from '../../../redis/redis.service';
import { ResetPasswordDto } from '../dto/password-reset.dto';
import { MailerService } from '../../mail/mail.service';
import { v4 as uuidv4 } from 'uuid';
import { PasswordService } from './password.service';
import { addMinutes, differenceInMinutes } from 'date-fns';
import { PerformanceService } from '../../../common/monitoring/performance.service';
import { LocationService } from './location.service';
import {
  AccountError,
  AppError,
  AuthenticationError,
  AuthorizationError,
  PasswordValidationError,
  ValidationError,
} from 'src/common/errors/custom-errors';
import { ErrorCodes } from 'src/common/errors/error-codes';
import { ErrorHandlingService } from 'src/common/errors/error-handling.service';

export interface SessionOptions {
  maxSessions?: number;
  forceLogoutOthers?: boolean;
}

interface LoginParams {
  loginDto: LoginDto;
  ipAddress: string;
  userAgent: string;
  sessionOptions?: SessionOptions;
}

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
    private sessionService: SessionService,
    private redisService: RedisService,
    private mailerService: MailerService,
    private performanceService: PerformanceService,
    private locationService: LocationService,
    private passwordService: PasswordService,
    private errorHandlingService: ErrorHandlingService,
  ) {}

  /**
   * Region for Prisma queries
   */

  async createUser(data: {
    username: string;
    email: string;
    password: string;
    firstName: string;
    lastName: string;
    verificationToken?: string;
    verificationExpiry?: Date;
    isEmailVerified?: boolean;
  }) {
    const defaultRole = await this.getDefaultRole();
    return this.prisma.user.create({
      data: {
        username: data.username,
        email: data.email,
        roleId: defaultRole.id,
        password: data.password,
        firstName: data.firstName,
        lastName: data.lastName,
        verificationToken: data.verificationToken,
        verificationExpiry: data.verificationExpiry,
        isEmailVerified: false,
      },
      include: {
        role: true,
      },
    });
  }

  async getDefaultRole() {
    this.logger.debug('Getting default role');
    const defaultRole = await this.prisma.role.findFirst({
      where: {
        name: 'user',
      },
    });
    if (!defaultRole) {
      this.logger.debug('Default role not found, creating one');
      return this.prisma.role.create({
        data: {
          name: 'user',
          permissions: {
            create: {
              name: 'read',
            },
          },
        },
      });
    }
    return defaultRole;
  }

  async addLoginAttempt(data: {
    userId: string;
    ipAddress: string;
    userAgent: string;
    success: boolean;
  }) {
    if (!data.userId) throw new Error('User id is required');
    if (!data.ipAddress) throw new Error('IP Address is required');

    const userExists = await this.checkIfUserExists({ id: data.userId });
    if (!userExists) {
      throw new Error('User does not exist');
    }

    return this.prisma.loginHistory.create({
      data: {
        userId: data.userId,
        ipAddress: data.ipAddress,
        userAgent: data.userAgent,
        success: data.success,
      },
    });
  }

  async checkIfUserExists(data: {
    username?: string;
    email?: string;
    id?: string;
  }) {
    return this.prisma.user.findFirst({
      where: {
        OR: [
          { email: data.email },
          { username: data.username },
          { id: data.id },
        ],
        deletedAt: null,
      },
    });
  }

  async getUser(data: { username?: string; email?: string; id?: string }) {
    return this.prisma.user.findFirst({
      where: {
        OR: [
          { email: data.email },
          { username: data.username },
          { id: data.id },
        ],
        deletedAt: null,
      },
    });
  }

  /**
   * End region
   */

  /**
   * Region for Auth methods
   */
  async login({
    loginDto,
    ipAddress,
    userAgent,
    sessionOptions = {},
  }: LoginParams) {
    return await this.performanceService.measureAsync('login', async () => {
      try {
        const user = await this.checkIfUserExists({
          username: loginDto.username,
          email: loginDto.username,
        });

        if (!user) {
          this.performanceService.incrementCounter('failed_logins');
          throw new AuthenticationError(
            'Invalid credentials',
            { code: ErrorCodes.AUTH.INVALID_CREDENTIALS },
            'login',
          );
        }

        if (user.deletedAt) {
          this.performanceService.incrementCounter('failed_logins');
          throw new AuthenticationError(
            'Email verification required. Please check your email.',
            { code: ErrorCodes.AUTH.EMAIL_NOT_VERIFIED },
            'login',
          );
        }

        if (user.accountLocked && user.lockExpires) {
          if (user.lockExpires > new Date()) {
            const remainingMinutes = differenceInMinutes(
              user.lockExpires,
              new Date(),
            );
            throw new AccountError(
              `Account temporarily locked. Try again in ${remainingMinutes} minutes`,
              {
                code: ErrorCodes.AUTH.ACCOUNT_LOCKED,
                remainingMinutes,
              },
              'login',
            );
          }
        }

        if (!user.isEmailVerified) {
          throw new AuthenticationError(
            'Email verification required. Please check your email.',
            { code: ErrorCodes.AUTH.EMAIL_NOT_VERIFIED },
            'login',
          );
        }

        // Check if account is locked
        if (user.accountLocked && user.lockExpires) {
          if (user.lockExpires > new Date()) {
            const remainingMinutes = differenceInMinutes(
              user.lockExpires,
              new Date(),
            );
            throw new UnauthorizedException(
              `Account temporarily locked for security. Please try again in ${remainingMinutes} minutes`,
            );
          } else {
            await this.resetFailedAttempts(user.id);
          }
        }

        const isPasswordValid = await bcrypt.compare(
          loginDto.password,
          user.password,
        );

        if (!isPasswordValid) {
          await this.handleFailedLogin(user);
          throw new AuthenticationError(
            'Invalid credentials',
            { code: ErrorCodes.AUTH.INVALID_CREDENTIALS },
            'login',
          );
        } else {
          const isNewLocation = await this.locationService.isNewLoginLocation(
            user.id,
            ipAddress,
          );

          if (isNewLocation) {
            const locationInfo =
              this.locationService.getLocationInfo(ipAddress);
            await this.mailerService.sendLoginAlert(user.email, {
              ip: ipAddress,
              browser: userAgent,
              location: locationInfo,
              time: new Date(),
            });
          }

          // If 2FA is enabled, return a different response
          if (user.twoFactorEnabled) {
            return {
              requires2FA: true,
              tempToken: this.generateTempToken(user),
            };
          }
        }

        // Reset failed attempts on successful login
        await this.resetFailedAttempts(user.id);

        // Track successful logins
        this.performanceService.incrementCounter('successful_logins');

        // Track active sessions
        this.performanceService.setGauge(
          'active_sessions',
          await this.sessionService
            .getUserSessions(user.id)
            .then((sessions) => sessions.length),
        );

        this.addLoginAttempt({
          userId: user.id,
          ipAddress: ipAddress,
          userAgent: userAgent,
          success: isPasswordValid,
        });

        const sessionId = await this.sessionService.createSession(
          user.id,
          {
            ipAddress,
            userAgent,
            lastActivity: new Date().toISOString(),
          },
          sessionOptions,
        );

        const token = this.generateToken(user);
        return { ...token, sessionId };
      } catch (error) {
        if (error instanceof AppError) {
          throw error;
        }
        this.errorHandlingService.handleAuthenticationError(error, 'login');
      }
    });
  }

  private generateTempToken(user: any) {
    const payload = {
      sub: user.id,
      type: '2fa-pending',
      exp: Math.floor(Date.now() / 1000) + 5 * 60,
    };
    return this.jwtService.sign(payload);
  }

  async checkPasswordHistory(
    userId: string,
    newPassword: string,
  ): Promise<boolean> {
    const recentPasswords = await this.prisma.passwordHistory.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 5,
    });

    for (const historical of recentPasswords) {
      if (await bcrypt.compare(newPassword, historical.password)) {
        throw new PasswordValidationError([
          'Password cannot be the same as any of the last 5 passwords',
        ]);
      }
    }

    return true;
  }

  async savePasswordToHistory(
    userId: string,
    hashedPassword: string,
  ): Promise<void> {
    await this.prisma.passwordHistory.create({
      data: {
        userId,
        password: hashedPassword,
      },
    });
  }

  async blockAccount(userId: string) {
    //TODO: Update to use Permissions and Roles
    return await this.performanceService.measureAsync(
      'blockAccount',
      async () => {
        await this.prisma.user.update({
          where: { id: userId },
          data: {
            deletedAt: new Date(),
          },
        });
      },
    );
  }

  async logoutAllDevices(
    userId: string,
    keepSessionId?: string,
  ): Promise<{ message: string; sessionsTerminated: number }> {
    return await this.performanceService.measureAsync(
      'logoutAllDevices',
      async () => {
        const sessions = await this.sessionService.getUserSessions(userId);
        let terminatedCount = 0;

        for (const sessionId of sessions) {
          if (!keepSessionId || sessionId !== keepSessionId) {
            await this.sessionService.destroySession(sessionId);
            terminatedCount++;
          }
        }

        // Track metrics
        this.performanceService.incrementCounter('mass_logout_events');
        this.performanceService.setGauge(
          'active_sessions_' + userId,
          keepSessionId ? 1 : 0,
        );

        return {
          message: keepSessionId
            ? 'Logged out from all other devices'
            : 'Logged out from all devices',
          sessionsTerminated: terminatedCount,
        };
      },
    );
  }

  private async handleFailedLogin(user: any) {
    const MAX_ATTEMPTS = 8;
    const LOCK_TIME = 15;

    const attempts = (user.failedLoginAttempts || 0) + 1;
    const updateData: any = {
      failedLoginAttempts: attempts,
      lastFailedLoginAttempt: new Date(),
    };

    if (attempts >= MAX_ATTEMPTS) {
      updateData.accountLocked = true;
      updateData.lockExpires = addMinutes(new Date(), LOCK_TIME);
    }

    await this.prisma.user.update({
      where: { id: user.id },
      data: updateData,
    });

    if (attempts >= MAX_ATTEMPTS) {
      throw new AuthorizationError(
        `Account locked for ${LOCK_TIME} minutes due to too many failed attempts`,
      );
    }
  }

  private async resetFailedAttempts(userId: string) {
    await this.prisma.user.update({
      where: { id: userId },
      data: {
        failedLoginAttempts: 0,
        accountLocked: false,
        lockExpires: null,
      },
    });
  }

  async logout(sessionId: string) {
    return await this.performanceService.measureAsync('logout', async () => {
      await this.sessionService.destroySession(sessionId);
      return { message: 'Logged out successfully' };
    });
  }

  async logoutAll(userId: string) {
    return await this.performanceService.measureAsync('logoutAll', async () => {
      await this.sessionService.revokeAllUserSessions(userId);
      return { message: 'Logged out of all sessions' };
    });
  }

  async register(registerDto: RegisterDto) {
    return await this.performanceService.measureAsync('register', async () => {
      try {
        const existingUser = await this.checkIfUserExists({
          email: registerDto.email,
          username: registerDto.username,
        });

        if (existingUser) {
          this.performanceService.incrementCounter('duplicate_registrations');
          if (existingUser.email === registerDto.email) {
            throw new ValidationError(
              'Email already in use',
              { code: ErrorCodes.ACCOUNT.ALREADY_EXISTS },
              'register',
            );
          }
          if (existingUser.username === registerDto.username) {
            throw new ValidationError(
              'Username already taken',
              { code: ErrorCodes.ACCOUNT.ALREADY_EXISTS },
              'register',
            );
          }
        }
        const passwordValidation = await this.passwordService.validatePassword(
          registerDto.password,
        );

        if (!passwordValidation.isValid) {
          throw new ValidationError(
            'Password validation failed',
            {
              code: ErrorCodes.VALIDATION.INVALID_PASSWORD,
              errors: passwordValidation.errors,
            },
            'register',
          );
        }

        this.performanceService.incrementCounter('successful_registrations');
        const hashedPassword = await bcrypt.hash(registerDto.password, 10);

        const verificationToken = uuidv4();
        const verificationExpiry = addMinutes(new Date(), 15);

        const user = await this.createUser({
          username: registerDto.username,
          email: registerDto.email,
          password: hashedPassword,
          firstName: registerDto.firstName,
          lastName: registerDto.lastName,
          verificationToken,
          verificationExpiry,
        });
        await this.savePasswordToHistory(user.id, hashedPassword);

        await this.mailerService.sendEmailVerification(
          user.email,
          verificationToken,
        );

        await this.mailerService.sendWelcome(user.email, user.username);
        return this.generateToken(user);
      } catch (error) {
        if (error instanceof AppError) {
          throw error;
        }
        this.errorHandlingService.handleValidationError(error, 'register');
      }
    });
  }

  async verifyEmail(token: string): Promise<{ message: string }> {
    const user = await this.prisma.user.findUnique({
      where: { verificationToken: token },
    });

    if (!user) {
      throw new UnauthorizedException('Invalid verification token');
    }

    if (user.isEmailVerified) {
      return { message: 'Email already verified' };
    }

    if (user.verificationExpiry && new Date() > user.verificationExpiry) {
      throw new UnauthorizedException('Verification token has expired');
    }

    await this.prisma.user.update({
      where: { id: user.id },
      data: {
        isEmailVerified: true,
        verificationToken: null,
        verificationExpiry: null,
      },
    });

    return { message: 'Email verified successfully' };
  }

  async resendVerificationEmail(email: string): Promise<{ message: string }> {
    const user = await this.prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      // Return success even if user doesn't exist (security through obscurity)
      return {
        message:
          'If your email is registered, a verification link has been sent',
      };
    }

    if (user.isEmailVerified) {
      return { message: 'Email already verified' };
    }

    // Generate new verification token
    const verificationToken = uuidv4();
    const verificationExpiry = addMinutes(new Date(), 15);
    await this.prisma.user.update({
      where: { id: user.id },
      data: {
        verificationToken,
        verificationExpiry,
      },
    });

    await this.mailerService.sendEmailVerification(email, verificationToken);

    return {
      message: 'If your email is registered, a verification link has been sent',
    };
  }

  async requestPasswordReset(email: string) {
    return await this.performanceService.measureAsync(
      'requestPasswordReset',
      async () => {
        try {
          const user = await this.prisma.user.findUnique({ where: { email } });
          if (!user) {
            return {
              message: 'If the email exists, a reset link has been sent',
            };
          }

          const token = crypto.randomBytes(32).toString('hex');
          await this.redisService.set(`pwd_reset:${token}`, user.id, 60 * 15);

          await this.mailerService.sendPasswordReset(email, token);

          return { message: 'If the email exists, a reset link has been sent' };
        } catch (error) {
          this.logger.error('Request Password Reset error', error.stack);
          throw error;
        }
      },
    );
  }

  async resetPassword(resetDto: ResetPasswordDto) {
    return await this.performanceService.measureAsync(
      'resetPassword',
      async () => {
        try {
          const userId = await this.redisService.get(
            `pwd_reset:${resetDto.token}`,
          );
          if (!userId) {
            throw new UnauthorizedException('Invalid or expired reset token');
          }

          const passwordValidation =
            await this.passwordService.validatePassword(resetDto.password);

          if (!passwordValidation.isValid) {
            throw new PasswordValidationError(passwordValidation.errors);
          }

          await this.checkPasswordHistory(userId, resetDto.password);

          const hashedPassword = await bcrypt.hash(resetDto.password, 10);
          await this.prisma.user.update({
            where: { id: userId },
            data: { password: hashedPassword },
          });
          this.sessionService.revokeAllUserSessions(userId);
          await this.savePasswordToHistory(userId, hashedPassword);

          await this.redisService.del(`pwd_reset:${resetDto.token}`);
          return { message: 'Password successfully reset' };
        } catch (error) {
          this.logger.error('Request Password Reset error', error.stack);
          throw error;
        }
      },
    );
  }

  private generateToken(user: any) {
    const payload = {
      sub: user.id,
      username: user.username,
      email: user.email,
    };

    return {
      access_token: this.jwtService.sign(payload),
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
      },
    };
  }
  /**
   * End region
   */
}


// modules/auth/services/device.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { UAParser } from 'ua-parser-js';
import * as crypto from 'crypto';
import { ErrorHandlingService } from 'src/common/errors/error-handling.service';

export interface DeviceInfo {
  deviceId: string;
  deviceName: string;
  browserInfo: string;
  osInfo: string;
  deviceType: string;
  isMobile: boolean;
}

@Injectable()
export class DeviceService {
  constructor(
    private prisma: PrismaService,
    private errorHandlingService: ErrorHandlingService,
  ) {}

  getDeviceInfo(userAgent: string): DeviceInfo {
    try {
      const parser = new UAParser(userAgent);
      const browser = parser.getBrowser();
      const os = parser.getOS();
      const device = parser.getDevice();

      const deviceId = crypto
        .createHash('md5')
        .update(`${userAgent}${os.name}${browser.name}`)
        .digest('hex');

      return {
        deviceId,
        deviceName: `${browser.name} on ${os.name}`,
        browserInfo: `${browser.name} ${browser.version || ''}`,
        osInfo: `${os.name} ${os.version || ''}`,
        deviceType: device.type || 'desktop',
        isMobile: device.type === 'mobile',
      };
    } catch (error) {
      this.errorHandlingService.handleValidationError(error, 'getDeviceInfo');
    }
  }

  async registerDevice(userId: string, userAgent: string): Promise<string> {
    try {
      const deviceInfo = this.getDeviceInfo(userAgent);

      const device = await this.prisma.userDevice.upsert({
        where: { deviceId: deviceInfo.deviceId },
        update: {
          lastUsedAt: new Date(),
          browser: deviceInfo.browserInfo,
          os: deviceInfo.osInfo,
        },
        create: {
          userId,
          deviceId: deviceInfo.deviceId,
          deviceName: deviceInfo.deviceName,
          deviceType: deviceInfo.deviceType,
          browser: deviceInfo.browserInfo,
          os: deviceInfo.osInfo,
        },
      });

      return device.deviceId;
    } catch (error) {
      this.errorHandlingService.handleDatabaseError(error, 'registerDevice');
    }
  }

  async getUserDevices(userId: string) {
    try {
      return this.prisma.userDevice.findMany({
        where: { userId },
        orderBy: { lastUsedAt: 'desc' },
      });
    } catch (error) {
      this.errorHandlingService.handleDatabaseError(error, 'getUserDevices');
    }
  }

  async setDeviceTrusted(deviceId: string, userId: string, trusted: boolean) {
    try {
      return this.prisma.userDevice.updateMany({
        where: {
          deviceId,
          userId,
        },
        data: { isTrusted: trusted },
      });
    } catch (error) {
      this.errorHandlingService.handleDatabaseError(error, 'setDeviceTrusted');
    }
  }

  async removeDevice(deviceId: string, userId: string) {
    try {
      return this.prisma.userDevice.deleteMany({
        where: {
          deviceId,
          userId,
        },
      });
    } catch (error) {
      this.errorHandlingService.handleDatabaseError(error, 'removeDevice');
    }
  }
}


// modules/auth/services/location.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import * as geoip from 'geoip-lite';
import { ErrorHandlingService } from 'src/common/errors/error-handling.service';
import { AppError, ValidationError } from 'src/common/errors/custom-errors';
import { ErrorCodes } from 'src/common/errors/error-codes';

@Injectable()
export class LocationService {
  constructor(
    private prisma: PrismaService,
    private errorHandlingService: ErrorHandlingService,
  ) {}

  async isNewLoginLocation(
    userId: string,
    ipAddress: string,
  ): Promise<boolean> {
    try {
      if (!ipAddress) {
        throw new ValidationError(
          'IP address is required',
          { code: ErrorCodes.VALIDATION.INVALID_INPUT },
          'isNewLoginLocation',
        );
      }

      const geo = geoip.lookup(ipAddress);
      if (!geo) return true;

      const recentLogin = await this.prisma.loginHistory.findFirst({
        where: {
          userId,
          ipAddress,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          },
        },
      });

      return !recentLogin;
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      this.errorHandlingService.handleValidationError(
        error,
        'isNewLoginLocation',
      );
    }
  }

  getLocationInfo(ipAddress: string) {
    try {
      if (!ipAddress) {
        throw new ValidationError(
          'IP address is required',
          { code: ErrorCodes.VALIDATION.INVALID_INPUT },
          'getLocationInfo',
        );
      }

      const geo = geoip.lookup(ipAddress);
      if (!geo) {
        return {
          country: 'Unknown',
          city: 'Unknown',
          timezone: 'Unknown',
        };
      }

      return {
        country: geo.country || 'Unknown',
        city: geo.city || 'Unknown',
        timezone: geo.timezone || 'Unknown',
      };
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      this.errorHandlingService.handleValidationError(error, 'getLocationInfo');
    }
  }
}


// modules/auth/services/password.service.ts
import { Injectable, Logger } from '@nestjs/common';
import * as crypto from 'crypto';
import fetch from 'node-fetch';
import { AppError, ValidationError } from 'src/common/errors/custom-errors';
import { ErrorCodes } from 'src/common/errors/error-codes';
import { ErrorHandlingService } from 'src/common/errors/error-handling.service';

@Injectable()
export class PasswordService {
  private readonly logger = new Logger(PasswordService.name);
  constructor(private readonly errorHandlingService: ErrorHandlingService) {}

  validatePasswordStrength(password: string): {
    isValid: boolean;
    errors: string[];
  } {
    try {
      const errors: string[] = [];

      if (password.length < 8) {
        errors.push('Password must be at least 8 characters long');
      }

      if (!/[A-Z]/.test(password)) {
        errors.push('Password must contain at least one uppercase letter');
      }

      if (!/[a-z]/.test(password)) {
        errors.push('Password must contain at least one lowercase letter');
      }

      if (!/\d/.test(password)) {
        errors.push('Password must contain at least one number');
      }

      if (!/[@$!%*?&-]/.test(password)) {
        errors.push(
          'Password must contain at least one special character (@$!%*?&-)',
        );
      }

      if (errors.length > 0) {
        throw new ValidationError(
          'Password validation failed',
          {
            code: ErrorCodes.VALIDATION.INVALID_PASSWORD,
            errors,
          },
          'validatePasswordStrength',
        );
      }

      return {
        isValid: true,
        errors: [],
      };
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      this.errorHandlingService.handleValidationError(
        error,
        'validatePasswordStrength',
      );
    }
  }

  async checkPasswordBreached(password: string): Promise<{
    isBreached: boolean;
    occurrences?: number;
  }> {
    try {
      const sha1 = crypto
        .createHash('sha1')
        .update(password)
        .digest('hex')
        .toUpperCase();
      const prefix = sha1.slice(0, 5);
      const suffix = sha1.slice(5);

      const response = await fetch(
        `https://api.pwnedpasswords.com/range/${prefix}`,
      );

      if (!response.ok) {
        throw new Error(`API request failed: ${response.statusText}`);
      }

      const text = await response.text();
      const lines = text.split('\n');

      for (const line of lines) {
        const [hash, count] = line.split(':');
        if (hash === suffix) {
          return {
            isBreached: true,
            occurrences: parseInt(count.trim(), 10),
          };
        }
      }

      return { isBreached: false };
    } catch (error) {
      this.logger.error('Password breach check failed:', error);
      return { isBreached: false };
    }
  }

  async validatePassword(password: string): Promise<{
    isValid: boolean;
    errors: string[];
  }> {
    try {
      const strengthCheck = this.validatePasswordStrength(password);
      if (!strengthCheck.isValid) {
        return strengthCheck;
      }

      const breachCheck = await this.checkPasswordBreached(password);
      if (breachCheck.isBreached) {
        throw new ValidationError(
          'Password found in data breach',
          {
            code: ErrorCodes.VALIDATION.PASSWORD_HISTORY,
            occurrences: breachCheck.occurrences,
          },
          'validatePassword',
        );
      }

      return { isValid: true, errors: [] };
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      this.errorHandlingService.handleValidationError(
        error,
        'validatePassword',
      );
    }
  }
}


// modules/auth/services/session.service.ts
import {
  BadRequestException,
  Injectable,
  Logger,
  NotFoundException,
} from '@nestjs/common';
import { RedisService } from 'src/redis/redis.service';
import { v4 as uuidv4 } from 'uuid';
import { DeviceService } from './device.service';
import { PerformanceService } from 'src/common/monitoring/performance.service';
import { AppError, SessionError } from 'src/common/errors/custom-errors';
import { ErrorCodes } from 'src/common/errors/error-codes';
import { ErrorHandlingService } from 'src/common/errors/error-handling.service';

interface SessionOptions {
  maxSessions?: number;
  forceLogoutOthers?: boolean;
}

interface SessionMetadata {
  ipAddress?: string;
  userAgent?: string;
  lastActivity?: string;
  deviceId?: string;
  [key: string]: any;
}

@Injectable()
export class SessionService {
  private readonly SESSION_PREFIX = 'session:';
  private readonly SESSION_TTL = 24 * 60 * 60;
  private readonly SESSION_REFRESH_THRESHOLD = 60 * 60;
  private readonly DEFAULT_MAX_SESSIONS = 5;

  private readonly logger = new Logger(SessionService.name);

  constructor(
    private readonly redisService: RedisService,
    private readonly deviceService: DeviceService,
    private readonly errorHandlingService: ErrorHandlingService,
    private readonly performanceService: PerformanceService,
  ) {}

  async createSession(
    userId: string,
    metadata: SessionMetadata = {},
    options: SessionOptions = {},
  ): Promise<string> {
    try {
      const currentSessions = await this.getUserSessions(userId);
      const maxSessions = options.maxSessions ?? this.DEFAULT_MAX_SESSIONS;

      if (currentSessions.length >= maxSessions) {
        if (options.forceLogoutOthers) {
          await Promise.all(
            currentSessions.map((sid) => this.destroySession(sid)),
          );
        } else {
          this.logger.warn(`Session limit reached for user ${userId}`);
          throw new SessionError(
            `Maximum sessions limit (${maxSessions}) reached`,
            {
              code: ErrorCodes.AUTH.SESSION_LIMIT_EXCEEDED,
              currentSessions: currentSessions.length,
              maxSessions,
            },
            'createSession',
          );
        }
      }

      const deviceId = await this.deviceService.registerDevice(
        userId,
        metadata.userAgent || 'unknown',
      );

      const sessionData = {
        userId,
        deviceId,
        createdAt: new Date().toISOString(),
        lastActivity: new Date().toISOString(),
        ...metadata,
      };

      const sessionId = uuidv4();
      const key = `${this.SESSION_PREFIX}${sessionId}`;

      await this.redisService.set(
        key,
        JSON.stringify(sessionData),
        this.SESSION_TTL,
      );

      // Track metrics
      this.performanceService.incrementCounter('sessions_created');
      this.performanceService.setGauge(
        `active_sessions_${userId}`,
        (await this.getUserSessions(userId)).length,
      );

      return sessionId;
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      this.errorHandlingService.handleSessionError(error, 'createSession');
    }
  }

  async validateSessionLimit(
    userId: string,
    maxSessions: number = this.DEFAULT_MAX_SESSIONS,
  ): Promise<boolean> {
    const sessions = await this.getUserSessions(userId);
    return sessions.length < maxSessions;
  }

  async forceLogoutOtherSessions(
    userId: string,
    currentSessionId: string,
  ): Promise<number> {
    const sessions = await this.getUserSessions(userId);
    let logoutCount = 0;

    for (const sessionId of sessions) {
      if (sessionId !== currentSessionId) {
        await this.destroySession(sessionId);
        logoutCount++;
      }
    }

    return logoutCount;
  }

  // Add this helper method to clean up old sessions
  async cleanupOldSessions(
    userId: string,
    maxAgeDays: number = 30,
  ): Promise<number> {
    const sessions = await this.getUserSessions(userId);
    let cleanedCount = 0;

    for (const sessionId of sessions) {
      const session = await this.getSession(sessionId);
      if (session) {
        const createdAt = new Date(session.createdAt);
        const ageInDays =
          (Date.now() - createdAt.getTime()) / (1000 * 60 * 60 * 24);

        if (ageInDays > maxAgeDays) {
          await this.destroySession(sessionId);
          cleanedCount++;
        }
      }
    }

    return cleanedCount;
  }

  async getSession(sessionId: string): Promise<any | null> {
    const data = await this.redisService.get(
      `${this.SESSION_PREFIX}${sessionId}`,
    );
    if (!data) return null;

    const session = JSON.parse(data);
    const timeLeft = await this.redisService.ttl(
      `${this.SESSION_PREFIX}${sessionId}`,
    );

    if (timeLeft < this.SESSION_REFRESH_THRESHOLD) {
      await this.refreshSession(sessionId, session);
    }

    return session;
  }

  async revokeDeviceSessions(
    userId: string,
    deviceId: string,
  ): Promise<number> {
    const sessions = await this.getUserSessions(userId);
    let revokedCount = 0;

    for (const sessionId of sessions) {
      const session = await this.getSession(sessionId);
      if (session && session.deviceId === deviceId) {
        await this.destroySession(sessionId);
        revokedCount++;
      }
    }

    // Track metric
    this.performanceService.incrementCounter('device_sessions_revoked');

    return revokedCount;
  }

  async getUserSessionsByDevice(
    userId: string,
    deviceId: string,
  ): Promise<string[]> {
    const sessions = await this.getUserSessions(userId);
    const deviceSessions = [];

    for (const sessionId of sessions) {
      const session = await this.getSession(sessionId);
      if (session && session.deviceId === deviceId) {
        deviceSessions.push(sessionId);
      }
    }

    return deviceSessions;
  }

  async refreshSession(sessionId: string, session: any): Promise<void> {
    session.lastActivity = new Date().toISOString();
    await this.redisService.set(
      `${this.SESSION_PREFIX}${sessionId}`,
      JSON.stringify(session),
      this.SESSION_TTL,
    );
  }

  async destroySession(sessionId: string): Promise<void> {
    await this.trackSessionActivity(sessionId, 'session_destroyed');
    await this.redisService.del(`${this.SESSION_PREFIX}${sessionId}`);
    await this.redisService.del(
      `${this.SESSION_PREFIX}${sessionId}:activities`,
    );
  }

  async validateSession(sessionId: string, userId: string): Promise<boolean> {
    try {
      const session = await this.getSession(sessionId);

      if (!session) {
        throw new SessionError(
          'Invalid session',
          { code: ErrorCodes.AUTH.SESSION_EXPIRED },
          'validateSession',
        );
      }

      if (session.userId !== userId) {
        throw new SessionError(
          'Session mismatch',
          { code: ErrorCodes.AUTH.INVALID_TOKEN },
          'validateSession',
        );
      }

      return true;
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      this.errorHandlingService.handleSessionError(error, 'validateSession');
    }
  }

  async getUserSessions(userId: string): Promise<string[]> {
    const sessions = await this.redisService.keys(`${this.SESSION_PREFIX}*`);
    const userSessions = [];

    for (const session of sessions) {
      const data = await this.redisService.get(session);
      if (data) {
        const parsed = JSON.parse(data);
        if (parsed.userId === userId) {
          userSessions.push(session.replace(this.SESSION_PREFIX, ''));
        }
      }
    }

    return userSessions;
  }

  async revokeAllUserSessions(
    userId: string,
    exceptSessionId?: string,
  ): Promise<void> {
    const sessions = await this.getUserSessions(userId);

    for (const sessionId of sessions) {
      if (sessionId !== exceptSessionId) {
        await this.destroySession(sessionId);
      }
    }
  }

  async extendSession(sessionId: string, duration?: number): Promise<void> {
    const maxDuration = 7 * 24 * 60 * 60; // 7 days
    const minDuration = 60 * 15; // 15 minutes

    // Validate duration
    if (duration) {
      if (duration > maxDuration) {
        throw new BadRequestException(
          `Session duration cannot exceed ${maxDuration} seconds`,
        );
      }
      if (duration < minDuration) {
        throw new BadRequestException(
          `Session duration must be at least ${minDuration} seconds`,
        );
      }
    }

    const session = await this.getSession(sessionId);
    if (!session) {
      throw new NotFoundException('Session not found');
    }

    const finalDuration = duration || this.SESSION_TTL;

    await this.redisService.set(
      `${this.SESSION_PREFIX}${sessionId}`,
      JSON.stringify({ ...session, lastActivity: new Date().toISOString() }),
      finalDuration,
    );

    await this.trackSessionActivity(sessionId, 'Session extended');
  }

  private async trackSessionActivity(
    sessionId: string,
    activity: string,
  ): Promise<void> {
    const session = await this.getSession(sessionId);
    if (session) {
      const activityLog = {
        timestamp: new Date().toISOString(),
        activity,
        sessionId,
        userId: session.userId,
      };

      await this.redisService.set(
        `${this.SESSION_PREFIX}${sessionId}:activities`,
        JSON.stringify(activityLog),
        this.SESSION_TTL,
      );
    }
  }
}


// modules/auth/services/two-factor.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import * as speakeasy from 'speakeasy';
import * as QRCode from 'qrcode';
import { AppError, TwoFactorError } from '../../../common/errors/custom-errors';
import { ErrorCodes } from '../../../common/errors/error-codes';
import { ErrorHandlingService } from 'src/common/errors/error-handling.service';

@Injectable()
export class TwoFactorService {
  constructor(
    private prisma: PrismaService,
    private errorHandlingService: ErrorHandlingService,
  ) {}

  async generateSecret(userId: string) {
    const secret = speakeasy.generateSecret({
      name: `Nibblix (${process.env.APP_ENV || 'development'})`,
    });

    // Store the secret temporarily
    await this.prisma.user.update({
      where: { id: userId },
      data: { twoFactorSecret: secret.base32 },
    });

    // Generate QR code
    const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);

    return {
      secret: secret.base32,
      qrCode: qrCodeUrl,
    };
  }

  async verifyToken(userId: string, token: string): Promise<boolean> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
        select: { twoFactorSecret: true },
      });

      if (!user?.twoFactorSecret) {
        throw new TwoFactorError(
          '2FA not set up for this account',
          { code: ErrorCodes.AUTH.TWO_FACTOR_REQUIRED },
          'verifyToken',
        );
      }

      const isValid = speakeasy.totp.verify({
        secret: user.twoFactorSecret,
        encoding: 'base32',
        token: token,
        window: 1,
      });

      if (!isValid) {
        throw new TwoFactorError(
          'Invalid 2FA token',
          { code: ErrorCodes.AUTH.INVALID_2FA_TOKEN },
          'verifyToken',
        );
      }

      return true;
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      this.errorHandlingService.handleAuthenticationError(error, 'verifyToken');
    }
  }

  async enable2FA(userId: string): Promise<void> {
    await this.prisma.user.update({
      where: { id: userId },
      data: { twoFactorEnabled: true },
    });
  }

  async disable2FA(userId: string): Promise<void> {
    await this.prisma.user.update({
      where: { id: userId },
      data: {
        twoFactorEnabled: false,
        twoFactorSecret: null,
      },
    });
  }
}


// modules/auth/strategies/jwt.strategy.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, ExtractJwt } from 'passport-jwt';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private prisma: PrismaService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET || 'your-secret-key', // Move to env variables in production
    });
  }

  async validate(payload: any) {
    const user = await this.prisma.user.findUnique({
      where: {
        id: payload.sub,
        deletedAt: null,
      },
    });

    if (!user) {
      throw new UnauthorizedException();
    }

    delete user.password;
    return user;
  }
}


// modules/mail/mail.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { MailerService } from './mail.service';
import { RedisModule } from 'src/redis/redis.module';

@Module({
  imports: [ConfigModule, RedisModule],
  providers: [MailerService],
  exports: [MailerService],
})
export class MailModule {}


// modules/mail/mail.service.ts
import { Injectable, Logger } from '@nestjs/common';
import * as nodemailer from 'nodemailer';
import { ConfigService } from '@nestjs/config';
import { RedisService } from 'src/redis/redis.service';

export interface MailOptions {
  to: string;
  subject: string;
  text?: string;
  html?: string;
}

const ETHEREAL_CACHE_KEY = 'ethereal_account';
const CACHE_TTL = 60 * 60 * 24 * 7; // 7 days

@Injectable()
export class MailerService {
  private transporter: nodemailer.Transporter;
  private readonly logger = new Logger(MailerService.name);

  constructor(
    private configService: ConfigService,
    private redisService: RedisService,
  ) {}

  async onModuleInit() {
    await this.initializeTransporter();
  }

  private async initializeTransporter() {
    try {
      if (this.configService.get('NODE_ENV') === 'development') {
        this.logger.debug('Initializing Ethereal Email transport');
        const etherealAccount = await this.getOrCreateEtherealAccount();

        if (etherealAccount) {
          this.transporter = nodemailer.createTransport({
            host: 'smtp.ethereal.email',
            port: 587,
            secure: false,
            auth: {
              user: etherealAccount.user,
              pass: etherealAccount.pass,
            },
          });
        } else {
          throw new Error('Failed to initialize Ethereal account');
        }
      } else {
        this.transporter = nodemailer.createTransport({
          host: this.configService.get('SMTP_HOST'),
          port: parseInt(this.configService.get('SMTP_PORT')),
          secure: this.configService.get('SMTP_SECURE') === 'true',
          auth: {
            user: this.configService.get('SMTP_USER'),
            pass: this.configService.get('SMTP_PASS'),
          },
        });
      }

      await this.transporter.verify();
      this.logger.log('Mail transporter initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize mail transporter:', error);
      throw error;
    }
  }

  async sendLoginAlert(
    email: string,
    data: {
      ip: string;
      browser: string;
      location: {
        country: string;
        city: string;
        timezone: string;
      };
      time: Date;
    },
  ) {
    const html = `
      <h2>New Login Detected</h2>
      <p>We detected a new login to your account from an unrecognized device:</p>
      <ul>
        <li>Time: ${data.time.toLocaleString()}</li>
        <li>Location: ${data.location.city}, ${data.location.country}</li>
        <li>IP Address: ${data.ip}</li>
        <li>Browser: ${data.browser}</li>
      </ul>
      <p>If this wasn't you, please change your password immediately and enable 2FA if you haven't already.</p>
    `;

    await this.transporter.sendMail({
      to: email,
      subject: 'New Login Alert',
      html,
    });
  }

  private async getOrCreateEtherealAccount(): Promise<any> {
    try {
      // Try to get cached account
      const cachedAccount = await this.redisService.get(ETHEREAL_CACHE_KEY);

      if (cachedAccount) {
        const parsed = JSON.parse(cachedAccount);

        // Verify cached credentials still work
        try {
          const testTransporter = nodemailer.createTransport({
            host: 'smtp.ethereal.email',
            port: 587,
            secure: false,
            auth: {
              user: parsed.user,
              pass: parsed.pass,
            },
          });
          await testTransporter.verify();

          this.logger.debug('Using cached Ethereal account');
          return parsed;
        } catch (error) {
          this.logger.warn(
            'Cached credentials invalid, creating new account',
            error,
          );
          await this.redisService.del(ETHEREAL_CACHE_KEY);
        }
      }

      // Create new account if none cached
      this.logger.debug('Creating new Ethereal account');
      const testAccount = await nodemailer.createTestAccount();

      if (testAccount) {
        // Cache the new account
        await this.redisService.set(
          ETHEREAL_CACHE_KEY,
          JSON.stringify(testAccount),
          CACHE_TTL,
        );
        return testAccount;
      }

      throw new Error('Failed to create Ethereal account');
    } catch (error) {
      this.logger.error('Failed to get/create Ethereal account:', error);
      return null;
    }
  }

  async sendEmailVerification(email: string, token: string): Promise<boolean> {
    const verificationLink = `${this.configService.get('FRONTEND_URL')}/verify-email?token=${token}`;

    return this.sendMail({
      to: email,
      subject: 'Verify Your Email',
      html: `
        <h1>Verify Your Email Address</h1>
        <p>Please click the link below to verify your email address:</p>
        <a href="${verificationLink}">Verify Email</a>
        <p>This link will expire in 15 minutes.</p>
        <p>If you didn't create an account, please ignore this email.</p>
      `,
    });
  }

  async sendMail(options: MailOptions): Promise<boolean> {
    try {
      if (!this.transporter) {
        await this.initializeTransporter();
      }

      const info = await this.transporter.sendMail({
        from: this.configService.get('SMTP_FROM') || 'noreply@nibblix.com',
        ...options,
      });

      if (this.configService.get('NODE_ENV') === 'development') {
        const previewUrl = nodemailer.getTestMessageUrl(info);
        this.logger.debug('=============== EMAIL SENT ===============');
        this.logger.debug(`Preview URL: ${previewUrl}`);
        this.logger.debug(`MessageId: ${info.messageId}`);
        this.logger.debug(`To: ${options.to}`);
        this.logger.debug(`Subject: ${options.subject}`);
        this.logger.debug('=======================================');
      }

      this.logger.log(`Email sent: ${info.messageId}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to send email: ${error.message}`, error.stack);
      return false;
    }
  }

  // Helper method for password reset emails
  async sendPasswordReset(email: string, token: string): Promise<boolean> {
    const resetLink = `${this.configService.get('FRONTEND_URL')}/reset-password?token=${token}`;

    return this.sendMail({
      to: email,
      subject: 'Password Reset Request',
      html: `
        <h1>Password Reset Request</h1>
        <p>You requested to reset your password. Click the link below to proceed:</p>
        <a href="${resetLink}">Reset Password</a>
        <p>If you didn't request this, please ignore this email.</p>
        <p>This link will expire in 30 minutes.</p>
      `,
    });
  }

  // Helper method for welcome emails
  async sendWelcome(email: string, username: string): Promise<boolean> {
    return this.sendMail({
      to: email,
      subject: 'Welcome to Nibblix',
      html: `
        <h1>Welcome to Nibblix, ${username}!</h1>
        <p>Thank you for joining our platform. We're excited to have you on board!</p>
        <p>If you have any questions, feel free to contact our support team.</p>
      `,
    });
  }
}


// modules/middleware/middleware.module.ts
import { Module } from '@nestjs/common';
import { SessionMiddleware } from '../auth/middleware/session.middleware';
import { RateLimitMiddleware } from '../auth/middleware/rate-limit.middleware';
import { RequestLoggerMiddleware } from '../auth/middleware/request-logger.middleware';
import { SessionService } from '../auth/services/session.service';
import { RedisModule } from '../../redis/redis.module';
import { DeviceModule } from '../auth/module/device.module';

@Module({
  imports: [RedisModule, DeviceModule],
  providers: [
    SessionMiddleware,
    RateLimitMiddleware,
    RequestLoggerMiddleware,
    SessionService,
  ],
  exports: [SessionMiddleware, RateLimitMiddleware, RequestLoggerMiddleware],
})
export class MiddlewareModule {}


// prisma/prisma.module.ts
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}


// prisma/prisma.service.ts
import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  private readonly logger = new Logger(PrismaService.name);

  async onModuleInit() {
    try {
      await this.$connect();
      this.logger.log('Successfully connected to database');

      // Test the connection by running a simple query
      await this.$queryRaw`SELECT 1`;
      this.logger.log('Database connection verified');
    } catch (error) {
      this.logger.error('Failed to connect to database:', error);
      throw error;
    }
  }
}


// redis/redis.module.ts
import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { RedisService } from './redis.service';
import { redisStore } from 'cache-manager-redis-store';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    CacheModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        store: redisStore as any,
        url: configService.get('REDIS_URL') || 'redis://redis:6379',
        isGlobal: true,
        ttl: 60 * 60 * 24, // 24 hours
      }),
      inject: [ConfigService],
    }),
  ],
  providers: [RedisService],
  exports: [RedisService, CacheModule],
})
export class RedisModule {}


// redis/redis.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class RedisService {
  constructor(@Inject(CACHE_MANAGER) private readonly cacheManager: Cache) {}

  async get(key: string): Promise<any> {
    return this.cacheManager.get(key);
  }

  async set(key: string, value: any, ttl: number): Promise<void> {
    await this.cacheManager.set(key, value, ttl * 1000);
  }

  async del(key: string): Promise<void> {
    await this.cacheManager.del(key);
  }

  async ttl(key: string): Promise<number> {
    const client = (this.cacheManager.store as any).getClient();
    return client.ttl(key);
  }

  async keys(pattern: string): Promise<string[]> {
    const client = (this.cacheManager.store as any).getClient();
    return client.keys(pattern);
  }
}


// request.http
### Authentication API Collection
@baseUrl = http://localhost:5000
@authToken = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI4N2MyNzAxNy03MTMyLTQxOTctYjYwMS1jZDM2NDdhNWVmYmUiLCJ1c2VybmFtZSI6InRlc3R1c2VyIiwiZW1haWwiOiJ0ZXN0dXNlckBleGFtcGxlLmNvbSIsImlhdCI6MTczNDU0OTY3NiwiZXhwIjoxNzM1MTU0NDc2LCJhdWQiOiJuaWJibGl4LWNsaWVudHMiLCJpc3MiOiJuaWJibGl4LmNvbSJ9.wH1j4tP42yg7LnX39XF3Feuzylhr3oE47re8Zn2nUYk
@sessionId = YOUR_SESSION_ID
@emailToken = 94402f12-81f9-420d-8d24-aa71cdcb0bf4

### Register a new user
POST {{baseUrl}}/auth/register
Content-Type: application/json

{
    "email": "testuser@example.com",
    "username": "testuser",
    "password": "daioUbdap09-0d0@dfa",
    "firstName": "Test",
    "lastName": "User"
}

### Register a new user
POST {{baseUrl}}/auth/register
Content-Type: application/json

{
    "email": "big@man.com",
    "username": "pwnagotchi",
    "password": "BigManFromTheHood",
    "firstName": "Raph",
    "lastName": "me"
}

### Login
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
    "username": "testuser",
    "password": "daioUbdap09-0d0@dfa"
}

### Get Current User
GET {{baseUrl}}/auth/me
Authorization: Bearer {{authToken}}

### Verify Email
POST {{baseUrl}}/auth/verify-email
Content-Type: application/json

{
    "token": "{{emailToken}}"
}

### Resend Verification Email
POST {{baseUrl}}/auth/resend-verification
Content-Type: application/json

{
    "email": "test@example.com"
}

### Request Password Reset
POST {{baseUrl}}/auth/password-reset/request
Content-Type: application/json

{
    "email": "test@example.com"
}

### Reset Password
POST {{baseUrl}}/auth/password-reset/reset
Content-Type: application/json

{
    "token": "TOKEN_FROM_EMAIL",
    "password": "NewPassword123!"
}

### Logout
POST {{baseUrl}}/auth/logout
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

### Logout from all devices
DELETE {{baseUrl}}/auth/logout-all
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

{
    "keepCurrentSession": true
}

### Get User Sessions
GET {{baseUrl}}/auth/sessions
Authorization: Bearer {{authToken}}

### Terminate Specific Session
DELETE {{baseUrl}}/auth/sessions/SESSION_ID
Authorization: Bearer {{authToken}}

### Extend Session
POST {{baseUrl}}/auth/extend-session
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

{
    "duration": 3600
}

### Get User Devices
GET {{baseUrl}}/auth/devices
Authorization: Bearer {{authToken}}

### Trust Device
POST {{baseUrl}}/auth/devices/DEVICE_ID/trust
Authorization: Bearer {{authToken}}

### Remove Device
DELETE {{baseUrl}}/auth/devices/DEVICE_ID
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

### Get Performance Metrics
GET {{baseUrl}}/auth/metrics
Authorization: Bearer {{authToken}}

### Block Account
POST {{baseUrl}}/auth/block
Authorization: Bearer {{authToken}}
session-id: {{sessionId}}

{
    "blockAccountId": "USER_ID_TO_BLOCK"
}

