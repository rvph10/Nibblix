// app.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});


// app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}


// app.module.ts
import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from './prisma/prisma.module';
import configuration from './config/configuration';
import { ThrottlerModule } from '@nestjs/throttler';
import { AuthModule } from './modules/auth/auth.module';
import { SessionMiddleware } from './modules/auth/middleware/session.middleware';
import { RateLimitMiddleware } from './modules/auth/middleware/rate-limit.middleware';
import { RequestLoggerMiddleware } from './modules/auth/middleware/request-logger.middleware';
import { RedisModule } from './redis/redis.module';
import { PrismaService } from './prisma/prisma.service';
import { MiddlewareModule } from './modules/middleware/middleware.module';
import { HealthController } from './health/health.controller';
import { MailModule } from './modules/mail/mail.module';
import { ErrorHandlingService } from './common/errors/error-handling.service';
import { SecurityHeadersMiddleware } from './common/security/security-headers.middleware';
import { MonitoringInterceptor } from './common/monitoring/monitor.interceptor';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { MonitoringModule } from './common/monitoring/monitoring.module';
import { MetricsService } from './common/monitoring/metrics.service';
import { HealthModule } from './health/health.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [configuration],
    }),
    ThrottlerModule.forRoot([
      {
        ttl: 60000,
        limit: 10,
      },
    ]),
    PrismaModule,
    AuthModule,
    RedisModule,
    MiddlewareModule,
    MailModule,
    MonitoringModule,
    AuthModule,
    HealthModule
  ],
  controllers: [HealthController],
  providers: [
    PrismaService, 
    ErrorHandlingService,
    MetricsService,
    {
      provide: APP_INTERCEPTOR,
      useClass: MonitoringInterceptor,
    }
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
    .apply(SecurityHeadersMiddleware, RequestLoggerMiddleware)
    .forRoutes('*');

    consumer
      .apply(RateLimitMiddleware)
      .exclude('health', 'public')
      .forRoutes('*');

    consumer.apply(SessionMiddleware).forRoutes('auth/*');
  }
}


// app.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}


// common/errors/custom-errors.ts
export class AppError extends Error {
    constructor(
      public readonly message: string,
      public readonly code: string,
      public readonly httpStatus: number,
      public readonly details?: any,
    ) {
      super(message);
      this.name = this.constructor.name;
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  export class DatabaseError extends AppError {
    constructor(message: string, details?: any) {
      super(message, 'DATABASE_ERROR', 500, details);
    }
  }
  
  export class ValidationError extends AppError {
    constructor(message: string, details?: any) {
      super(message, 'VALIDATION_ERROR', 400, details);
    }
  }
  
  export class AuthenticationError extends AppError {
    constructor(message: string, details?: any) {
      super(message, 'AUTHENTICATION_ERROR', 401, details);
    }
  }
  
  export class AuthorizationError extends AppError {
    constructor(message: string, details?: any) {
      super(message, 'AUTHORIZATION_ERROR', 403, details);
    }
  }

// common/errors/error-codes.ts
export const DATABASE_ERRORS = {
    UNIQUE_CONSTRAINT: 'P2002',
    RECORD_NOT_FOUND: 'P2025',
    INVALID_DATA: 'P2014'
  } as const;
  
  export const AUTH_ERRORS = {
    INVALID_CREDENTIALS: 'AUTH001',
    TOKEN_EXPIRED: 'AUTH002',
    INVALID_TOKEN: 'AUTH003',
    UNAUTHORIZED: 'AUTH004'
  } as const;
  
  export const VALIDATION_ERRORS = {
    INVALID_INPUT: 'VAL001',
    MISSING_FIELD: 'VAL002',
    INVALID_FORMAT: 'VAL003'
  } as const;
  
  export const BUSINESS_ERRORS = {
    RESOURCE_NOT_FOUND: 'BUS001',
    INSUFFICIENT_PERMISSIONS: 'BUS002',
    INVALID_OPERATION: 'BUS003'
  } as const;

// common/errors/error-handling.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import * as ErrorCodes from './error-codes';
import { DatabaseError, ValidationError } from './custom-errors';

@Injectable()
export class ErrorHandlingService {
  private readonly logger = new Logger(ErrorHandlingService.name);

  handleDatabaseError(error: Error, context: string): never {
    this.logger.error(`Database error in ${context}:`, error.stack);

    if (error instanceof PrismaClientKnownRequestError) {
      switch (error.code) {
        case ErrorCodes.DATABASE_ERRORS.UNIQUE_CONSTRAINT:
          throw new DatabaseError('Unique constraint violation', {
            fields: error.meta?.target,
          });
        case ErrorCodes.DATABASE_ERRORS.RECORD_NOT_FOUND:
          throw new DatabaseError('Record not found');
        case ErrorCodes.DATABASE_ERRORS.INVALID_DATA:
          throw new DatabaseError('Invalid data provided');
        default:
          throw new DatabaseError('Database operation failed');
      }
    }

    throw new DatabaseError('Unexpected database error');
  }

  handleValidationError(error: Error, context: string): never {
    this.logger.error(`Validation error in ${context}:`, error.stack);
    throw new ValidationError(error.message, {
      code: ErrorCodes.VALIDATION_ERRORS.INVALID_INPUT
    });
  }

  handleAuthError(error: Error, context: string): never {
    this.logger.error(`Authentication error in ${context}:`, error.stack);
    throw new ValidationError(error.message, {
      code: ErrorCodes.AUTH_ERRORS.INVALID_CREDENTIALS
    });
  }

  logError(error: Error, context: string): void {
    this.logger.error(
      `Error in ${context}:`,
      error.stack,
      {
        name: error.name,
        message: error.message,
        timestamp: new Date().toISOString(),
      }
    );
  }
}

// common/filters/global-exception.filter.ts
import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    HttpStatus,
    Logger,
  } from '@nestjs/common';
  import { Request, Response } from 'express';
  import { AppError } from '../errors/custom-errors';
  
  @Catch()
  export class GlobalExceptionFilter implements ExceptionFilter {
    private readonly logger = new Logger(GlobalExceptionFilter.name);
  
    catch(exception: Error, host: ArgumentsHost) {
      const ctx = host.switchToHttp();
      const response = ctx.getResponse<Response>();
      const request = ctx.getRequest<Request>();
  
      let status = HttpStatus.INTERNAL_SERVER_ERROR;
      let message = 'Internal server error';
      let code = 'INTERNAL_SERVER_ERROR';
      let details = null;
  
      if (exception instanceof AppError) {
        status = exception.httpStatus;
        message = exception.message;
        code = exception.code;
        details = exception.details;
      } else if (exception instanceof HttpException) {
        status = exception.getStatus();
        message = exception.message;
      }
  
      // Log the error
      this.logger.error(
        `${request.method} ${request.url}`,
        {
          error: exception,
          stack: exception.stack,
          body: request.body,
          params: request.params,
          query: request.query,
        },
      );
  
      // Send response
      response.status(status).json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
        method: request.method,
        message,
        code,
        details,
      });
    }
  }

// common/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger('HttpException');

  catch(exception: Error, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const message =
      exception instanceof HttpException
        ? exception.message
        : 'Internal server error';

    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message: message,
    };

    this.logger.error(
      `${request.method} ${request.url}`,
      exception.stack,
      'ExceptionFilter',
    );

    response.status(status).json(errorResponse);
  }
}


// common/monitoring/circuit-breaker.service.ts
import { Injectable, Logger } from '@nestjs/common';

@Injectable()
export class CircuitBreakerService {
  private readonly logger = new Logger(CircuitBreakerService.name);
  private state: Map<string, CircuitState> = new Map();

  async executeWithBreaker<T>(
    name: string,
    operation: () => Promise<T>,
    options: CircuitBreakerOptions = {}
  ): Promise<T> {
    if (this.isOpen(name)) {
      throw new Error('Circuit is open');
    }

    try {
      const result = await operation();
      this.recordSuccess(name);
      return result;
    } catch (error) {
      this.recordFailure(name);
      throw error;
    }
  }

  private isOpen(name: string): boolean {
    const circuit = this.state.get(name);
    if (!circuit) return false;
    
    return circuit.failures >= circuit.threshold &&
           Date.now() - circuit.lastFailure < circuit.resetTimeout;
  }

  private recordSuccess(name: string) {
    const circuit = this.state.get(name);
    if (circuit) {
      circuit.failures = 0;
    }
  }

  private recordFailure(name: string) {
    const circuit = this.state.get(name) || this.createCircuit(name);
    circuit.failures++;
    circuit.lastFailure = Date.now();
    this.state.set(name, circuit);
  }

  private createCircuit(name: string): CircuitState {
    return {
      failures: 0,
      threshold: 5,
      resetTimeout: 60000,
      lastFailure: 0
    };
  }
}

interface CircuitState {
  failures: number;
  threshold: number;
  resetTimeout: number;
  lastFailure: number;
}

interface CircuitBreakerOptions {
  threshold?: number;
  resetTimeout?: number;
}

// common/monitoring/logger.service.ts
import { ConsoleLogger, Injectable } from '@nestjs/common';
import * as winston from 'winston';
import 'winston-daily-rotate-file';

@Injectable()
export class CustomLoggerService extends ConsoleLogger {
  private winston: winston.Logger;

  constructor() {
    super();
    this.initializeWinston();
  }

  private initializeWinston() {
    const fileFormat = winston.format.combine(
      winston.format.timestamp(),
      winston.format.json()
    );

    this.winston = winston.createLogger({
      level: 'info',
      format: fileFormat,
      transports: [
        new winston.transports.DailyRotateFile({
          filename: 'logs/error-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          level: 'error',
          maxSize: '20m',
          maxFiles: '14d'
        }),
        new winston.transports.DailyRotateFile({
          filename: 'logs/combined-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          maxSize: '20m',
          maxFiles: '14d'
        })
      ]
    });

    if (process.env.NODE_ENV !== 'production') {
      this.winston.add(new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.simple()
        )
      }));
    }
  }

  log(message: any, context?: string) {
    this.winston.info(message, { context });
    super.log(message, context);
  }

  error(message: any, stack?: string, context?: string) {
    this.winston.error(message, { stack, context });
    super.error(message, stack, context);
  }

  warn(message: any, context?: string) {
    this.winston.warn(message, { context });
    super.warn(message, context);
  }

  debug(message: any, context?: string) {
    this.winston.debug(message, { context });
    super.debug(message, context);
  }

  verbose(message: any, context?: string) {
    this.winston.verbose(message, { context });
    super.verbose(message, context);
  }
}

// common/monitoring/metrics.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as promClient from "prom-client";

@Injectable()
export class MetricsService implements OnModuleInit {
  private readonly register: promClient.Registry;
  private httpRequestDuration: promClient.Histogram;
  private httpRequestTotal: promClient.Counter;

  constructor(private config: ConfigService) {
    this.register = new promClient.Registry();
     promClient.collectDefaultMetrics({ register: this.register });
  }

  onModuleInit() {
    this.initializeMetrics();
  }

  private initializeMetrics() {
    this.httpRequestDuration = new promClient.Histogram({
      name: 'http_request_duration_seconds',
      help: 'Duration of HTTP requests in seconds',
      labelNames: ['method', 'route', 'status_code'],
      buckets: [0.1, 0.5, 1, 2, 5]
    });

    this.httpRequestTotal = new promClient.Counter({
      name: 'http_requests_total',
      help: 'Total number of HTTP requests',
      labelNames: ['method', 'route', 'status_code']
    });

    this.register.registerMetric(this.httpRequestDuration);
    this.register.registerMetric(this.httpRequestTotal);
  }

  recordHttpRequest(method: string, route: string, statusCode: number, duration: number) {
    this.httpRequestDuration.labels(method, route, statusCode.toString()).observe(duration);
    this.httpRequestTotal.labels(method, route, statusCode.toString()).inc();
  }

  async getMetrics(): Promise<string> {
    return this.register.metrics();
  }
}

// common/monitoring/monitor.decorator.ts
import { applyDecorators, SetMetadata } from '@nestjs/common';

export function Monitor(options: { name: string; threshold?: number }) {
  return applyDecorators(
    SetMetadata('monitor', options)
  );
}

// common/monitoring/monitor.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler, Logger } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class MonitoringInterceptor implements NestInterceptor {
  private readonly logger = new Logger('APIMonitoring');

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const { method, path, ip, headers } = request;
    const userAgent = headers['user-agent'] || 'unknown';
    const startTime = Date.now();

    return next.handle().pipe(
      tap({
        next: (response: any) => {
          const endTime = Date.now();
          const duration = endTime - startTime;
          
          this.logger.log({
            type: 'API_CALL',
            method,
            path,
            duration: `${duration}ms`,
            ip,
            userAgent,
            userId: request.user?.id,
            statusCode: context.switchToHttp().getResponse().statusCode,
            timestamp: new Date().toISOString()
          });
        },
        error: (error: Error) => {
          const endTime = Date.now();
          const duration = endTime - startTime;

          this.logger.error({
            type: 'API_ERROR',
            method,
            path,
            duration: `${duration}ms`,
            ip,
            userAgent,
            userId: request.user?.id,
            error: {
              name: error.name,
              message: error.message,
              stack: error.stack
            },
            timestamp: new Date().toISOString()
          });
        }
      })
    );
  }
}

// common/monitoring/monitoring.module.ts
import { Global, Module } from '@nestjs/common';
import { MonitoringInterceptor } from './monitor.interceptor';
import { PerformanceService } from './performance.service';
import { CustomLoggerService } from './logger.service';

@Global()
@Module({
  providers: [
    MonitoringInterceptor,
    PerformanceService,
    CustomLoggerService,
    {
      provide: 'Logger',
      useClass: CustomLoggerService,
    }
  ],
  exports: [
    MonitoringInterceptor,
    PerformanceService,
    CustomLoggerService,
    'Logger'
  ]
})
export class MonitoringModule {}

// common/monitoring/performance.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { performance } from 'perf_hooks';

@Injectable()
export class PerformanceService {
  private readonly logger = new Logger('Performance');
  private metrics: Map<string, number[]> = new Map();
  private counters: Map<string, number> = new Map();
  private gauges: Map<string, number> = new Map();

  trackMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name).push(value);
  }

  async measureAsync<T>(name: string, operation: () => Promise<T>): Promise<T> {
    const start = performance.now();
    try {
      const result = await operation();
      const duration = performance.now() - start;
      this.trackMetric(name, duration);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      this.trackMetric(`${name}_error`, duration);
      throw error;
    }
  }

  private calculatePercentile(values: number[], percentile: number): number {
    const sorted = [...values].sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }

  getMetricsSummary() {
    const summary = {
      timers: {},
      counters: {},
      gauges: {}
    };

    // Process timers
    this.metrics.forEach((values, name) => {
      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      summary.timers[name] = {
        average: avg.toFixed(2),
        min: Math.min(...values).toFixed(2),
        max: Math.max(...values).toFixed(2),
        count: values.length,
        p95: this.calculatePercentile(values, 95).toFixed(2)
      };
    });

    // Add counters and gauges
    summary.counters = Object.fromEntries(this.counters);
    summary.gauges = Object.fromEntries(this.gauges);

    return summary;
  }

  incrementCounter(name: string) {
    const current = this.counters.get(name) || 0;
    this.counters.set(name, current + 1);
  }

  setGauge(name: string, value: number) {
    this.gauges.set(name, value);
  }

  clearMetrics() {
    this.metrics.clear();
  }
}

// common/security/request-sanitizer.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import * as sanitizeHtml from 'sanitize-html';

@Injectable()
export class RequestSanitizerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    if (req.body) {
      this.sanitizeObject(req.body);
    }
    
    if (req.query) {
      this.sanitizeObject(req.query);
    }

    if (req.params) {
      this.sanitizeObject(req.params);
    }

    next();
  }

  private sanitizeObject(obj: any) {
    Object.keys(obj).forEach(key => {
      if (typeof obj[key] === 'string') {
        obj[key] = this.sanitizeInput(obj[key]);
      } else if (typeof obj[key] === 'object') {
        this.sanitizeObject(obj[key]);
      }
    });
  }

  private sanitizeInput(input: string): string {
    return sanitizeHtml(input, {
      allowedTags: [],
      allowedAttributes: {},
      disallowedTagsMode: 'recursiveEscape'
    });
  }
}

// common/security/security-headers.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import helmet from 'helmet';

@Injectable()
export class SecurityHeadersMiddleware implements NestMiddleware {
  private readonly helmetMiddleware: any;

  constructor() {
    this.helmetMiddleware = helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", 'data:', 'https:'],
          connectSrc: ["'self'"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      },
      crossOriginEmbedderPolicy: true,
      crossOriginOpenerPolicy: true,
      crossOriginResourcePolicy: { policy: 'same-origin' },
      dnsPrefetchControl: true,
      frameguard: { action: 'deny' },
      hidePoweredBy: true,
      hsts: true,
      ieNoOpen: true,
      noSniff: true,
      referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
      xssFilter: true,
    });
  }

  use(req: Request, res: Response, next: NextFunction) {
    this.helmetMiddleware(req, res, next);
  }
}

// config/configuration.ts
/**
 * Application configuration object.
 * @returns {Object} Configuration object with various settings
 */
export default () => ({
  port: parseInt(process.env.PORT, 10) || 3000,
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
  },
  email: {
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT, 10) || 587,
    user: process.env.EMAIL_USER,
    password: process.env.EMAIL_PASSWORD,
  },
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY,
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
  },
});


// health/health.controller.ts
import { Controller, Get, Logger } from '@nestjs/common';
import { HealthService } from './health.service';
import { HealthStatus } from './types';

@Controller('health')
export class HealthController {
  private readonly logger = new Logger(HealthController.name);

  constructor(private healthService: HealthService) {}

  @Get()
  async check(): Promise<HealthStatus | { status: 'error'; error: string; timestamp: string }> {
    try {
      const healthCheck = await this.healthService.checkHealth();
      this.logger.debug('Health check completed', healthCheck);
      return healthCheck;
    } catch (error) {
      this.logger.error('Health check failed', error.stack);
      return {
        status: 'error',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
}

// health/health.module.ts
import { Module } from '@nestjs/common';
import { HealthController } from './health.controller';
import { HealthService } from './health.service';
import { PrismaModule } from '../prisma/prisma.module';
import { RedisModule } from '../redis/redis.module';

@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [HealthController],
  providers: [HealthService],
  exports: [HealthService],
})
export class HealthModule {}

// health/health.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RedisService } from '../redis/redis.service';
import { HealthCheckResult, HealthStatus, MemoryHealthCheck } from './types';

@Injectable()
export class HealthService {
  private readonly logger = new Logger(HealthService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService
  ) {}

  async checkHealth(): Promise<HealthStatus> {
    const checks = {
      database: await this.checkDatabase(),
      redis: await this.checkRedis(),
      memory: this.checkMemory(),
      uptime: process.uptime()
    };

    return {
      status: this.determineOverallStatus(checks),
      checks,
      timestamp: new Date().toISOString()
    };
  }

  private determineOverallStatus(checks: {
    database: HealthCheckResult;
    redis: HealthCheckResult;
    memory: MemoryHealthCheck;
    uptime: number;
  }): 'ok' | 'error' {
    const statuses = [checks.database, checks.redis, checks.memory];
    return statuses.every(check => check.status === 'ok') ? 'ok' : 'error';
  }

  private async checkDatabase(): Promise<HealthCheckResult> {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return { status: 'ok' };
    } catch (error) {
      this.logger.error('Database health check failed', error.stack);
      return { status: 'error', error: error.message };
    }
  }

  private async checkRedis(): Promise<HealthCheckResult> {
    try {
      await this.redis.set('health-check', 'ok', 10);
      await this.redis.get('health-check');
      return { status: 'ok' };
    } catch (error) {
      this.logger.error('Redis health check failed', error.stack);
      return { status: 'error', error: error.message };
    }
  }

  private checkMemory(): MemoryHealthCheck {
    const used = process.memoryUsage();
    return {
      status: 'ok',
      heap: Math.round(used.heapUsed / 1024 / 1024),
      rss: Math.round(used.rss / 1024 / 1024)
    };
  }
}

// health/types.ts
export interface HealthCheckResult {
    status: 'ok' | 'error';
    error?: string;
  }
  
  export interface MemoryHealthCheck {
    status: 'ok';
    heap: number;
    rss: number;
  }
  
  export interface HealthStatus {
    status: 'ok' | 'error';
    checks: {
      database: HealthCheckResult;
      redis: HealthCheckResult;
      memory: MemoryHealthCheck;
      uptime: number;
    };
    timestamp: string;
  }

// main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe, Logger } from '@nestjs/common';
import { GlobalExceptionFilter } from './common/filters/global-exception.filter';
import { CustomLoggerService } from './common/monitoring/logger.service';

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule, 
    {
      logger: new CustomLoggerService()
  });

  app.enableCors({
    origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
    credentials: true,
  });

  app.useGlobalFilters(new GlobalExceptionFilter());
  app.useLogger(new CustomLoggerService()); 

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
      disableErrorMessages: process.env.NODE_ENV === 'production',
    }),
  );

  const port = process.env.PORT || 5000;
  const host = process.env.HOST || '0.0.0.0';
  await app.listen(port, host);
  logger.log(`Application is running on: http://localhost:${port}`);
}
bootstrap();


// modules/auth/auth.controller.ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Req,
  UnauthorizedException,
  UseGuards,
  Headers,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { Request } from 'express';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { RequestResetDto, ResetPasswordDto } from './dto/password-reset.dto';
import { Throttle } from '@nestjs/throttler';
import { JwtAuthGuard } from './guard/jwt-auth.guard';
import { SessionService } from './session.service';
import { SessionGuard } from './guard/session.guard';
import { PerformanceService } from 'src/common/monitoring/performance.service';

@Controller('auth')
export class AuthController {
  constructor(
    private authService: AuthService,
    private sessionService: SessionService,
    private performanceService: PerformanceService
  ) {}

  @Get('metrics')
  @UseGuards(JwtAuthGuard)
  async getMetrics() {
    const metrics = this.performanceService.getMetricsSummary();
    return {
      metrics,
      timestamp: new Date().toISOString()
    };
  }

  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  @Throttle({ default: { limit: 5, ttl: 60000 } })
  login(@Body() loginDto: LoginDto, @Req() request: Request) {
    return this.authService.login({
      loginDto,
      ipAddress: request.ip,
      userAgent: request.headers['user-agent'] || 'unknown',
    });
  }

  @Post('logout')
  @HttpCode(HttpStatus.OK)
  @UseGuards(JwtAuthGuard, SessionGuard)
  async logout(@Headers('session-id') sessionId: string) {
    return this.authService.logout(sessionId);
  }

  @Post('password-reset/request')
  @HttpCode(HttpStatus.OK)
  @Throttle({ default: { limit: 3, ttl: 300000 } }) // 5 minutes
  async requestPasswordReset(@Body() resetDto: RequestResetDto) {
    return this.authService.requestPasswordReset(resetDto.email);
  }

  @Post('password-reset/reset')
  @HttpCode(HttpStatus.OK)
  async resetPassword(@Body() resetDto: ResetPasswordDto) {
    return this.authService.resetPassword(resetDto);
  }

  @Get('sessions')
  @UseGuards(JwtAuthGuard)
  async getSessions(@Req() req: Request & { user: any }) {
    const sessions = await this.sessionService.getUserSessions(req.user.id);
    return { sessions };
  }

  @Delete('sessions/:sessionId')
  @HttpCode(HttpStatus.OK)
  @UseGuards(JwtAuthGuard)
  async terminateSession(
    @Param('sessionId') sessionId: string,
    @Req() req: Request & { user: any },
  ) {
    const session = await this.sessionService.getSession(sessionId);
    if (!session) {
      throw new UnauthorizedException('Session not found');
    }

    if (session.userId !== req.user.id) {
      throw new UnauthorizedException('Unauthorized to terminate this session');
    }

    await this.sessionService.destroySession(sessionId);
    return { message: 'Session terminated successfully' };
  }

  @Delete('sessions')
  @HttpCode(HttpStatus.OK)
  @UseGuards(JwtAuthGuard)
  async terminateAllSessions(
    @Headers('session-id') currentSessionId: string,
    @Req() req: Request & { user: any },
  ) {
    const sessions = await this.sessionService.getUserSessions(req.user.id);
    
    for (const sessionId of sessions) {
      // Skip the current session
      if (sessionId !== currentSessionId) {
        await this.sessionService.destroySession(sessionId);
      }
    }

    return { message: 'All other sessions terminated successfully' };
  }

  @Get('me')
  @UseGuards(JwtAuthGuard)
  async getCurrentUser(@Req() req: Request & { user: any }) {
    // Remove sensitive information
    const { password, ...user } = req.user;
    return user;
  }
}

// modules/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { JwtStrategy } from './strategies/jwt.strategy';
import { PrismaService } from '../../prisma/prisma.service';
import { RedisModule } from 'src/redis/redis.module';
import { SessionService } from './session.service';
import { MailModule } from '../mail/mail.module';
import { PerformanceService } from 'src/common/monitoring/performance.service';

@Module({
  imports: [
    RedisModule,
    MailModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: {
        expiresIn: process.env.JWT_EXPIRES_IN || '1d',
        issuer: 'nibblix.com',
        audience: 'nibblix-clients',
      },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, PrismaService, SessionService, PerformanceService],
  exports: [AuthService, SessionService],
})
export class AuthModule {}


// modules/auth/auth.service.ts
import {
  Injectable,
  UnauthorizedException,
  ConflictException,
  Logger,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as crypto from 'crypto';
import { PrismaService } from '../../prisma/prisma.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import * as bcrypt from 'bcryptjs';
import { SessionService } from './session.service';
import { RedisService } from '../../redis/redis.service';
import { ResetPasswordDto } from './dto/password-reset.dto';
import { MailerService } from '../mail/mail.service';
import { PerformanceService } from 'src/common/monitoring/performance.service';

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
    private sessionService: SessionService,
    private redisService: RedisService,
    private mailerService: MailerService,
    private performanceService: PerformanceService
  ) {}

  /**
   * Region for Prisma queries
   */

  async createUser(data: {
    username: string;
    email: string;
    password: string;
    firstName: string;
    lastName: string;
  }) {
    const defaultRole = await this.getDefaultRole();
    this.logger.debug('Creating user in database');
    return this.prisma.user.create({
      data: {
        username: data.username,
        email: data.email,
        roleId: defaultRole.id,
        password: data.password,
        firstName: data.firstName,
        lastName: data.lastName,
      },
      include: {
        role: true,
      },
    });
  }

  async getDefaultRole() {
    this.logger.debug('Getting default role');
    const defaultRole = await this.prisma.role.findFirst({
      where: {
        name: 'user',
      },
    });
    if (!defaultRole) {
      this.logger.debug('Default role not found, creating one');
      return this.prisma.role.create({
        data: {
          name: 'user',
          permissions: {
            create: {
              name: 'read',
            },
          },
        },
      });
    }
    return defaultRole;
  }

  async addLoginAttempt(data: {
    userId: string;
    ipAddress: string;
    userAgent: string;
    success: boolean;
  }) {
    if (!data.userId) throw new Error('User id is required');
    if (!data.ipAddress) throw new Error('IP Address is required');

    const userExists = await this.checkIfUserExists({ id: data.userId });
    if (!userExists) {
      throw new Error('User does not exist');
    }

    return this.prisma.loginHistory.create({
      data: {
        userId: data.userId,
        ipAddress: data.ipAddress,
        userAgent: data.userAgent,
        success: data.success,
      },
    });
  }

  async checkIfUserExists(data: {
    username?: string;
    email?: string;
    id?: string;
  }) {
    return this.prisma.user.findFirst({
      where: {
        OR: [
          { email: data.email },
          { username: data.username },
          { id: data.id },
        ],
        deletedAt: null,
      },
    });
  }

  async getUser(data: { username?: string; email?: string; id?: string }) {
    return this.prisma.user.findFirst({
      where: {
        OR: [
          { email: data.email },
          { username: data.username },
          { id: data.id },
        ],
        deletedAt: null,
      },
    });
  }

  /**
   * End region
   */

  /**
   * Region for Auth methods
   */
  async login(data: {
    loginDto: LoginDto;
    ipAddress: string;
    userAgent: string;
  }) {
    return await this.performanceService.measureAsync('login', async () => {
      try {
        const user = await this.getUser({ username: data.loginDto.username });

        if (!user || user.deletedAt) {
          throw new UnauthorizedException('Invalid credentials');
        }

        const isPasswordValid = await bcrypt.compare(
          data.loginDto.password,
          user.password,
        );
        if (!isPasswordValid) {
          throw new UnauthorizedException('Invalid credentials');
        }

        this.addLoginAttempt({
          userId: user.id,
          ipAddress: data.ipAddress,
          userAgent: data.userAgent,
          success: isPasswordValid,
        });

        const sessionId = await this.sessionService.createSession(user.id, {
          ipAddress: data.ipAddress,
          userAgent: data.userAgent,
          lastActivity: new Date().toISOString(),
        });

        const token = this.generateToken(user);
        return { ...token, sessionId };
      } catch (error) {
        this.logger.error('Login failed', error.stack);
        throw error;
      }
    });
  }

  async logout(sessionId: string) {
    return await this.performanceService.measureAsync('logout', async () => {
      await this.sessionService.destroySession(sessionId);
      return { message: 'Logged out successfully' };
    });
  }

  async register(registerDto: RegisterDto) {
    return await this.performanceService.measureAsync('register', async () => {
      try {
        this.logger.debug('Starting registration process');
  
        const existingUser = await this.checkIfUserExists({
          email: registerDto.email,
          username: registerDto.username,
        });
  
        if (existingUser) {
          if (existingUser.email === registerDto.email) {
            throw new ConflictException('Email already in use');
          }
          if (existingUser.username === registerDto.username) {
            throw new ConflictException('Username already in use');
          }
        }
        const hashedPassword = await bcrypt.hash(registerDto.password, 10);
  
        const user = await this.createUser({
          username: registerDto.username,
          email: registerDto.email,
          password: hashedPassword,
          firstName: registerDto.firstName,
          lastName: registerDto.lastName,
        });
  
        await this.mailerService.sendWelcome(user.email, user.username);
  
        this.logger.debug('User created successfully', user);
        return this.generateToken(user);
      } catch (error) {
        this.logger.error('Registration error', error.stack);
        throw error;
      }
    });
  }

  async requestPasswordReset(email: string) {
    return await this.performanceService.measureAsync('requestPasswordReset', async () => {
      try {
        const user = await this.prisma.user.findUnique({ where: { email } });
    if (!user) {
        // Return success even if user doesn't exist (security)
        return { message: 'If the email exists, a reset link has been sent' };
    }

    const token = crypto.randomBytes(32).toString('hex');
    await this.redisService.set(
        `pwd_reset:${token}`,
        user.id,
        60 * 15,
    );

    await this.mailerService.sendPasswordReset(email, token);

    return { message: 'If the email exists, a reset link has been sent' };
      } catch (error) {
        this.logger.error('Request Password Reset error', error.stack);
        throw error;
      }
    });
}

  async resetPassword(resetDto: ResetPasswordDto) {
    return await this.performanceService.measureAsync('resetPassword', async () => {
      try {
        const userId = await this.redisService.get(`pwd_reset:${resetDto.token}`);
    if (!userId) {
      throw new UnauthorizedException('Invalid or expired reset token');
    }

    const hashedPassword = await bcrypt.hash(resetDto.password, 10);
    await this.prisma.user.update({
      where: { id: userId },
      data: { password: hashedPassword },
    });

    await this.redisService.del(`pwd_reset:${resetDto.token}`);
    return { message: 'Password successfully reset' };
      } catch (error) {
        this.logger.error('Request Password Reset error', error.stack);
        throw error;
      }
    });
  }

  private generateToken(user: any) {
    const payload = {
      sub: user.id,
      username: user.username,
      email: user.email,
    };

    return {
      access_token: this.jwtService.sign(payload),
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
      },
    };
  }
  /**
   * End region
   */
}


// modules/auth/dto/login.dto.ts
import { IsString, MinLength } from 'class-validator';

export class LoginDto {
  @IsString()
  @MinLength(3)
  username: string;

  @IsString()
  @MinLength(6)
  password: string;
}


// modules/auth/dto/password-reset.dto.ts
import { IsEmail, IsString, MinLength, Matches } from 'class-validator';

export class RequestResetDto {
  @IsEmail()
  email: string;
}

export class ResetPasswordDto {
  @IsString()
  token: string;

  @IsString()
  @MinLength(8)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message: 'Password must contain uppercase, lowercase, number and special character',
  })
  password: string;
}

// modules/auth/dto/register.dto.ts
import {
  IsEmail,
  IsString,
  MinLength,
  IsOptional,
  IsDate,
  Matches,
} from 'class-validator';
import { Type } from 'class-transformer';

export class RegisterDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(3)
  username: string;

  @IsString()
  @MinLength(8)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message:
      'Password must contain uppercase, lowercase, number and special character',
  })
  password: string;

  @IsString()
  @IsOptional()
  firstName?: string;

  @IsString()
  @IsOptional()
  lastName?: string;

  @IsDate()
  @IsOptional()
  @Type(() => Date)
  birthDate?: Date;
}


// modules/auth/guard/jwt-auth.guard.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}


// modules/auth/guard/session.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { SessionService } from '../session.service';

@Injectable()
export class SessionGuard implements CanActivate {
  constructor(private sessionService: SessionService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const sessionId = request.headers['session-id'];

    if (!sessionId) {
      throw new UnauthorizedException('No session provided');
    }

    const session = await this.sessionService.getSession(sessionId);
    if (!session) {
      throw new UnauthorizedException('Invalid session');
    }

    request.session = session;
    return true;
  }
}


// modules/auth/middleware/rate-limit.middleware.ts
import {
  Injectable,
  NestMiddleware,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { RedisService } from 'src/redis/redis.service';

@Injectable()
export class RateLimitMiddleware implements NestMiddleware {
  constructor(private readonly redisService: RedisService) {}

  async use(req: Request, res: Response, next: NextFunction) {
    const ip = req.ip;
    const key = `rateLimit:${ip}`;
    const limit = 100;
    const window = 60 * 15;

    const current = await this.redisService.get(key);

    if (!current) {
      await this.redisService.set(key, '1', window);
      next();
      return;
    }

    const count = parseInt(current);
    if (count > limit) {
      throw new HttpException(
        'Too many requests',
        HttpStatus.TOO_MANY_REQUESTS,
      );
    }

    await this.redisService.set(key, (count + 1).toString(), window);
    next();
  }
}


// modules/auth/middleware/request-logger.middleware.ts
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class RequestLoggerMiddleware implements NestMiddleware {
  private logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction) {
    const { ip, method, originalUrl } = req;
    const userAgent = req.get('user-agent') || '';

    res.on('finish', () => {
      const { statusCode } = res;
      const contentLength = res.get('content-length');

      this.logger.log(
        `${method} ${originalUrl} ${statusCode} ${contentLength} - ${userAgent} ${ip}`,
      );
    });

    next();
  }
}


// modules/auth/middleware/session.middleware.ts
import {
  Injectable,
  NestMiddleware,
  UnauthorizedException,
} from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { SessionService } from '../session.service';

@Injectable()
export class SessionMiddleware implements NestMiddleware {
  constructor(private readonly sessionService: SessionService) {}

  async use(req: Request, res: Response, next: NextFunction) {
    const sessionId = req.headers['session-id'] as string;

    if (!sessionId) {
      return next();
    }

    const session = await this.sessionService.getSession(sessionId);
    if (!session) {
      throw new UnauthorizedException('Invalid session');
    }

    req['session'] = session;
    next();
  }
}


// modules/auth/session.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { RedisService } from 'src/redis/redis.service';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class SessionService {
  private readonly SESSION_PREFIX = 'session:';
  private readonly SESSION_TTL = 24 * 60 * 60;
  private readonly SESSION_REFRESH_THRESHOLD = 60 * 60;

  constructor(private readonly redisService: RedisService) {}

  async createSession(userId: string, metadata: any = {}): Promise<string> {
    const sessionId = uuidv4();
    const sessionData = {
      userId,
      createdAt: new Date().toISOString(),
      lastActivity: new Date().toISOString(),
      ...metadata,
    };

    await this.redisService.set(
      `${this.SESSION_PREFIX}${sessionId}`,
      JSON.stringify(sessionData),
      this.SESSION_TTL,
    );

    return sessionId;
  }

  async getSession(sessionId: string): Promise<any | null> {
    const data = await this.redisService.get(
      `${this.SESSION_PREFIX}${sessionId}`,
    );
    if (!data) return null;

    const session = JSON.parse(data);
    const timeLeft = await this.redisService.ttl(
      `${this.SESSION_PREFIX}${sessionId}`,
    );

    if (timeLeft < this.SESSION_REFRESH_THRESHOLD) {
      await this.refreshSession(sessionId, session);
    }

    return session;
  }

  async refreshSession(sessionId: string, session: any): Promise<void> {
    session.lastActivity = new Date().toISOString();
    await this.redisService.set(
      `${this.SESSION_PREFIX}${sessionId}`,
      JSON.stringify(session),
      this.SESSION_TTL,
    );
  }

  async destroySession(sessionId: string): Promise<void> {
    await this.redisService.del(`${this.SESSION_PREFIX}${sessionId}`);
  }

  async validateSession(sessionId: string, userId: string): Promise<boolean> {
    const session = await this.getSession(sessionId);
    return session?.userId === userId;
  }

  async getUserSessions(userId: string): Promise<string[]> {
    const sessions = await this.redisService.keys(`${this.SESSION_PREFIX}*`);
    const userSessions = [];

    for (const session of sessions) {
      const data = await this.redisService.get(session);
      if (data) {
        const parsed = JSON.parse(data);
        if (parsed.userId === userId) {
          userSessions.push(session.replace(this.SESSION_PREFIX, ''));
        }
      }
    }

    return userSessions;
  }
}


// modules/auth/strategies/jwt.strategy.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, ExtractJwt } from 'passport-jwt';
import { PrismaService } from '../../../prisma/prisma.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private prisma: PrismaService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET || 'your-secret-key', // Move to env variables in production
    });
  }

  async validate(payload: any) {
    const user = await this.prisma.user.findUnique({
      where: {
        id: payload.sub,
        deletedAt: null,
      },
    });

    if (!user) {
      throw new UnauthorizedException();
    }

    delete user.password;
    return user;
  }
}


// modules/auth/tests/auth.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from '../auth.controller';
import { AuthService } from '../auth.service';
import { SessionService } from '../session.service';
import { UnauthorizedException } from '@nestjs/common';

describe('AuthController', () => {
  let controller: AuthController;
  let authService: AuthService;
  let sessionService: SessionService;

  const mockAuthService = {
    register: jest.fn(),
    login: jest.fn(),
    logout: jest.fn(),
    requestPasswordReset: jest.fn(),
    resetPassword: jest.fn(),
  };

  const mockSessionService = {
    getSession: jest.fn(),
    destroySession: jest.fn(),
    getUserSessions: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: mockAuthService,
        },
        {
          provide: SessionService,
          useValue: mockSessionService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
    authService = module.get<AuthService>(AuthService);
    sessionService = module.get<SessionService>(SessionService);

    jest.clearAllMocks();
  });

  describe('register', () => {
    const registerDto = {
      email: 'test@example.com',
      username: 'testuser',
      password: 'Password123!',
      firstName: 'Test',
      lastName: 'User',
    };

    it('should register a new user successfully', async () => {
      const expectedResponse = {
        access_token: 'jwt_token',
        user: {
          id: '1',
          ...registerDto,
        },
      };

      mockAuthService.register.mockResolvedValue(expectedResponse);

      const result = await controller.register(registerDto);

      expect(result).toBe(expectedResponse);
      expect(mockAuthService.register).toHaveBeenCalledWith(registerDto);
    });
  });

  describe('login', () => {
    const loginDto = {
      username: 'testuser',
      password: 'Password123!',
    };

    const mockRequest = {
      ip: '127.0.0.1',
      headers: {
        'user-agent': 'test-browser',
      },
    };

    it('should login successfully', async () => {
      const expectedResponse = {
        access_token: 'jwt_token',
        sessionId: 'session-id',
        user: {
          id: '1',
          username: 'testuser',
        },
      };

      mockAuthService.login.mockResolvedValue(expectedResponse);

      const result = await controller.login(loginDto, mockRequest as any);

      expect(result).toBe(expectedResponse);
      expect(mockAuthService.login).toHaveBeenCalledWith({
        loginDto,
        ipAddress: mockRequest.ip,
        userAgent: mockRequest.headers['user-agent'],
      });
    });
  });

  describe('password reset', () => {
    const requestResetDto = {
      email: 'test@example.com',
    };

    const resetPasswordDto = {
      token: 'reset-token',
      password: 'NewPassword123!',
    };

    it('should request password reset successfully', async () => {
      const expectedResponse = {
        message: 'If the email exists, a reset link has been sent',
      };

      mockAuthService.requestPasswordReset.mockResolvedValue(expectedResponse);

      const result = await controller.requestPasswordReset(requestResetDto);

      expect(result).toBe(expectedResponse);
      expect(mockAuthService.requestPasswordReset).toHaveBeenCalledWith(
        requestResetDto.email,
      );
    });

    it('should reset password successfully', async () => {
      const expectedResponse = {
        message: 'Password successfully reset',
      };

      mockAuthService.resetPassword.mockResolvedValue(expectedResponse);

      const result = await controller.resetPassword(resetPasswordDto);

      expect(result).toBe(expectedResponse);
      expect(mockAuthService.resetPassword).toHaveBeenCalledWith(
        resetPasswordDto,
      );
    });
  });

  describe('session management', () => {
    const mockUser = {
      id: '1',
      username: 'testuser',
    };

    const mockSession = {
      id: 'session-id',
      userId: '1',
    };

    describe('getSessions', () => {
      it('should return user sessions', async () => {
        const mockSessions = ['session1', 'session2'];
        mockSessionService.getUserSessions.mockResolvedValue(mockSessions);

        const result = await controller.getSessions({ user: mockUser } as any);

        expect(result).toEqual({ sessions: mockSessions });
        expect(mockSessionService.getUserSessions).toHaveBeenCalledWith(mockUser.id);
      });
    });

    describe('terminateSession', () => {
      it('should terminate session successfully', async () => {
        mockSessionService.getSession.mockResolvedValue(mockSession);

        const result = await controller.terminateSession('session-id', {
          user: mockUser,
        } as any);

        expect(result).toEqual({ message: 'Session terminated successfully' });
        expect(mockSessionService.destroySession).toHaveBeenCalledWith('session-id');
      });

      it('should throw UnauthorizedException for non-existent session', async () => {
        mockSessionService.getSession.mockResolvedValue(null);

        await expect(
          controller.terminateSession('session-id', { user: mockUser } as any),
        ).rejects.toThrow(UnauthorizedException);
      });

      it('should throw UnauthorizedException for unauthorized session termination', async () => {
        mockSessionService.getSession.mockResolvedValue({
          ...mockSession,
          userId: 'different-user',
        });

        await expect(
          controller.terminateSession('session-id', { user: mockUser } as any),
        ).rejects.toThrow(UnauthorizedException);
      });
    });

    describe('terminateAllSessions', () => {
      it('should terminate all other sessions successfully', async () => {
        const mockSessions = ['session1', 'session2', 'current-session'];
        mockSessionService.getUserSessions.mockResolvedValue(mockSessions);

        const result = await controller.terminateAllSessions('current-session', {
          user: mockUser,
        } as any);

        expect(result).toEqual({ message: 'All other sessions terminated successfully' });
        expect(mockSessionService.destroySession).toHaveBeenCalledTimes(2);
        expect(mockSessionService.destroySession).not.toHaveBeenCalledWith(
          'current-session',
        );
      });
    });

    describe('getCurrentUser', () => {
      it('should return current user information', async () => {
        const mockUserWithPassword = {
          ...mockUser,
          password: 'hashed_password',
        };

        const result = await controller.getCurrentUser({
          user: mockUserWithPassword,
        } as any);

        expect(result).toEqual(mockUser);
        expect(result).not.toHaveProperty('password');
      });
    });
  });
});

// modules/auth/tests/auth.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from '../auth.service';
import { PrismaService } from '../../../prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';
import { ConflictException, UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcryptjs';
import { SessionService } from '../session.service';
import { RedisService } from '../../../redis/redis.service';
import { MailerService } from '../../mail/mail.service';

describe('AuthService', () => {
  let service: AuthService;
  let prismaService: PrismaService;
  let jwtService: JwtService;

  const mockPrismaService = {
    user: {
      findFirst: jest.fn(),
      create: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
    },
    role: {
      findFirst: jest.fn(),
      create: jest.fn(),
    },
    loginHistory: {
      create: jest.fn(),
    },
  };

  const mockJwtService = {
    sign: jest.fn(),
  };

  const mockSessionService = {
    createSession: jest.fn(),
    destroySession: jest.fn(),
    getSession: jest.fn(),
  };

  const mockRedisService = {
    set: jest.fn(),
    get: jest.fn(),
    del: jest.fn(),
  };

  const mockMailerService = {
    sendMail: jest.fn(),
    sendPasswordReset: jest.fn(),
    sendWelcome: jest.fn(),
  };


  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: JwtService,
          useValue: mockJwtService,
        },
        {
          provide: SessionService,
          useValue: mockSessionService,
        },
        {
          provide: RedisService,
          useValue: mockRedisService,
        },
        {
          provide: MailerService,
          useValue: mockMailerService,
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    prismaService = module.get<PrismaService>(PrismaService);
    jwtService = module.get<JwtService>(JwtService);

    jest.clearAllMocks();

    jest.spyOn(service, 'getDefaultRole').mockResolvedValue({
      id: 'default-role-id',
      name: 'user',
      permissions: {},
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    jest.spyOn(service, 'checkIfUserExists')
      .mockImplementation(async (data) => {
        const result = await mockPrismaService.user.findFirst();
        if (!result) {
          return null;
        }
        return result;
      });
  });

  describe('register', () => {
    const registerDto = {
      email: 'test@example.com',
      username: 'testuser',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
    };

    it('should register a new user successfully', async () => {
      const hashedPassword = 'hashedPassword';
      jest.spyOn(bcrypt, 'hash').mockResolvedValue(hashedPassword as never);
      mockPrismaService.user.findFirst.mockResolvedValue(null);
      mockPrismaService.user.create.mockResolvedValue({
        ...registerDto,
        id: '1',
        password: hashedPassword,
        roleId: 'default-role-id',
      });
      mockJwtService.sign.mockReturnValue('jwt_token');

      const result = await service.register(registerDto);

      expect(result).toHaveProperty('access_token');
      expect(result).toHaveProperty('user');
      expect(mockPrismaService.user.create).toHaveBeenCalledWith({
        data: {
          ...registerDto,
          password: hashedPassword,
          roleId: 'default-role-id',
        },
        include: {
          role: true,
        },
      });
    });

    it('should throw ConflictException if user already exists', async () => {
      const existingUser = {
        id: '1',
        email: registerDto.email,
        username: registerDto.username,
      };

      mockPrismaService.user.findFirst.mockResolvedValue(existingUser);

      await expect(service.register(registerDto)).rejects.toThrow(
        ConflictException,
      );
    });
  });

  describe('login', () => {
    const loginDto = {
      username: 'testuser',
      password: 'password123',
    };

    it('should login successfully with correct credentials', async () => {
      const user = {
        id: '1',
        username: loginDto.username,
        password: 'hashedPassword',
        email: 'test@example.com',
      };

      mockPrismaService.user.findFirst.mockResolvedValue(user);
      jest.spyOn(bcrypt, 'compare').mockResolvedValue(true as never);
      mockJwtService.sign.mockReturnValue('jwt_token');

      const result = await service.login({
        loginDto,
        ipAddress: '127.0.0.1',
        userAgent: 'test-agent',
      });

      expect(result).toHaveProperty('access_token');
      expect(result).toHaveProperty('user');
    });

    it('should throw UnauthorizedException with incorrect password', async () => {
      mockPrismaService.user.findFirst.mockResolvedValue({
        password: 'hashedPassword',
      });
      jest.spyOn(bcrypt, 'compare').mockResolvedValue(false as never);

      await expect(
        service.login({
          loginDto,
          ipAddress: '127.0.0.1',
          userAgent: 'test-agent',
        }),
      ).rejects.toThrow(UnauthorizedException);
    });

    it('should throw UnauthorizedException if user not found', async () => {
      mockPrismaService.user.findFirst.mockResolvedValue(null);

      await expect(
        service.login({
          loginDto,
          ipAddress: '127.0.0.1',
          userAgent: 'test-agent',
        }),
      ).rejects.toThrow(UnauthorizedException);
    });
  });

  describe('createUser', () => {
    it('should create a new user with default role', async () => {
      const userData = {
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123',
        firstName: 'Test',
        lastName: 'User',
      };

      const defaultRole = { id: 'default-role-id', name: 'user' };
      mockPrismaService.role.findFirst.mockResolvedValue(defaultRole);
      mockPrismaService.user.create.mockResolvedValue({
        ...userData,
        id: '1',
        role: defaultRole,
        roleId: defaultRole.id,
      });

      const result = await service.createUser(userData);

      expect(result).toHaveProperty('id');
      expect(result).toHaveProperty('role');
      expect(result.role).toEqual(defaultRole);
      expect(mockPrismaService.user.create).toHaveBeenCalledWith({
        data: {
          ...userData,
          roleId: defaultRole.id,
        },
        include: {
          role: true,
        },
      });
    });
  });

  describe('addLoginAttempt', () => {
    it('should add a login attempt successfully', async () => {
      const loginAttemptData = {
        userId: '1',
        ipAddress: '127.0.0.1',
        userAgent: 'test-agent',
        success: true,
      };

      mockPrismaService.user.findFirst.mockResolvedValue({ id: '1' });
      mockPrismaService.loginHistory.create.mockResolvedValue(loginAttemptData);

      const result = await service.addLoginAttempt(loginAttemptData);

      expect(result).toEqual(loginAttemptData);
      expect(mockPrismaService.loginHistory.create).toHaveBeenCalledWith({
        data: loginAttemptData,
      });
    });

    it('should throw an error if user does not exist', async () => {
      const loginAttemptData = {
        userId: '1',
        ipAddress: '127.0.0.1',
        userAgent: 'test-agent',
        success: true,
      };

      mockPrismaService.user.findFirst.mockResolvedValue(null);

      await expect(service.addLoginAttempt(loginAttemptData)).rejects.toThrow(
        'User does not exist',
      );
    });
  });

  describe('login with session', () => {
    it('should create session on successful login', async () => {
      const loginDto = {
        username: 'testuser',
        password: 'password123',
      };

      const user = {
        id: '1',
        username: loginDto.username,
        password: 'hashedPassword',
        email: 'test@example.com',
      };

      mockPrismaService.user.findFirst.mockResolvedValue(user);
      jest.spyOn(bcrypt, 'compare').mockResolvedValue(true as never);
      mockJwtService.sign.mockReturnValue('jwt_token');
      mockSessionService.createSession.mockResolvedValue('session-id');

      const result = await service.login({
        loginDto,
        ipAddress: '127.0.0.1',
        userAgent: 'test-agent',
      });

      expect(result).toHaveProperty('sessionId');
      expect(mockSessionService.createSession).toHaveBeenCalledWith(
        user.id,
        expect.objectContaining({
          ipAddress: '127.0.0.1',
          userAgent: 'test-agent',
        }),
      );
    });
  });

  describe('logout', () => {
    it('should destroy session on logout', async () => {
      const sessionId = 'test-session';
      await service.logout(sessionId);

      expect(mockSessionService.destroySession).toHaveBeenCalledWith(sessionId);
    });
  });

  describe('password reset', () => {
    const email = 'test@example.com';
    const token = 'reset-token';
    const userId = 'user-id';

    it('should handle password reset request successfully', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue({
        id: userId,
        email,
      });

      await service.requestPasswordReset(email);

      expect(mockRedisService.set).toHaveBeenCalledWith(
        expect.stringContaining('pwd_reset:'),
        userId,
        15 * 60, // 15 minutes
      );
      expect(mockMailerService.sendPasswordReset).toHaveBeenCalledWith(
        email,
        expect.any(String),
      );
    });

    it('should handle non-existent email for password reset', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue(null);

      const result = await service.requestPasswordReset(email);

      expect(result.message).toBe('If the email exists, a reset link has been sent');
      expect(mockRedisService.set).not.toHaveBeenCalled();
      expect(mockMailerService.sendPasswordReset).not.toHaveBeenCalled();
    });

    it('should reset password successfully', async () => {
      const newPassword = 'newPassword123!';
      mockRedisService.get.mockResolvedValue(userId);

      await service.resetPassword({ token, password: newPassword });

      expect(mockPrismaService.user.update).toHaveBeenCalledWith({
        where: { id: userId },
        data: { password: expect.any(String) },
      });
      expect(mockRedisService.del).toHaveBeenCalledWith(`pwd_reset:${token}`);
    });

    it('should throw UnauthorizedException for invalid reset token', async () => {
      mockRedisService.get.mockResolvedValue(null);

      await expect(
        service.resetPassword({ token, password: 'newPassword123!' }),
      ).rejects.toThrow(UnauthorizedException);
    });
  });
});


// modules/auth/tests/session.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { SessionService } from '../session.service';
import { RedisService } from 'src/redis/redis.service';

describe('SessionService', () => {
  let sessionService: SessionService;
  let redisService: RedisService;

  const mockRedisService = {
    set: jest.fn(),
    get: jest.fn(),
    del: jest.fn(),
    ttl: jest.fn(),
    keys: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SessionService,
        {
          provide: RedisService,
          useValue: mockRedisService,
        },
      ],
    }).compile();

    sessionService = module.get<SessionService>(SessionService);
    redisService = module.get<RedisService>(RedisService);

    jest.clearAllMocks();
  });

  describe('createSession', () => {
    const userId = 'test-user-id';
    const metadata = {
      ipAddress: '127.0.0.1',
      userAgent: 'test-agent',
    };

    it('should create a new session', async () => {
      const sessionData = {
        userId,
        createdAt: expect.any(String),
        lastActivity: expect.any(String),
        ...metadata,
      };

      await sessionService.createSession(userId, metadata);

      expect(redisService.set).toHaveBeenCalledWith(
        expect.stringContaining('session:'),
        expect.stringContaining(userId),
        24 * 60 * 60,
      );

      const setCall = (redisService.set as jest.Mock).mock.calls[0];
      const savedData = JSON.parse(setCall[1]);
      expect(savedData).toMatchObject(sessionData);
    });
  });

  describe('getSession', () => {
    const sessionId = 'test-session-id';
    const sessionData = {
      userId: 'test-user-id',
      createdAt: new Date().toISOString(),
      lastActivity: new Date().toISOString(),
    };

    it('should return session data and refresh if close to expiry', async () => {
      mockRedisService.get.mockResolvedValue(JSON.stringify(sessionData));
      mockRedisService.ttl.mockResolvedValue(30 * 60);
      const result = await sessionService.getSession(sessionId);
      expect(result).toEqual({
        userId: sessionData.userId,
        createdAt: expect.any(String),
        lastActivity: expect.any(String),
      });

      expect(new Date(result.createdAt).getTime()).not.toBeNaN();
      expect(new Date(result.lastActivity).getTime()).not.toBeNaN();
      expect(redisService.set).toHaveBeenCalled();
    });

    it('should return null for non-existent session', async () => {
      mockRedisService.get.mockResolvedValue(null);

      const result = await sessionService.getSession(sessionId);
      expect(result).toBeNull();
    });

    it('should return session data without refresh if not close to expiry', async () => {
      mockRedisService.get.mockResolvedValue(JSON.stringify(sessionData));
      mockRedisService.ttl.mockResolvedValue(2 * 60 * 60);

      const result = await sessionService.getSession(sessionId);

      expect(result).toEqual({
        userId: sessionData.userId,
        createdAt: expect.any(String),
        lastActivity: expect.any(String),
      });

      expect(new Date(result.createdAt).getTime()).not.toBeNaN();
      expect(new Date(result.lastActivity).getTime()).not.toBeNaN();
      expect(redisService.set).not.toHaveBeenCalled();
    });
  });

  describe('validateSession', () => {
    const sessionId = 'test-session-id';
    const userId = 'test-user-id';

    it('should return true for valid session', async () => {
      const sessionData = { userId };
      mockRedisService.get.mockResolvedValue(JSON.stringify(sessionData));
      mockRedisService.ttl.mockResolvedValue(2 * 60 * 60);

      const result = await sessionService.validateSession(sessionId, userId);
      expect(result).toBe(true);
    });

    it('should return false for invalid session', async () => {
      const sessionData = { userId: 'different-user' };
      mockRedisService.get.mockResolvedValue(JSON.stringify(sessionData));
      mockRedisService.ttl.mockResolvedValue(2 * 60 * 60);

      const result = await sessionService.validateSession(sessionId, userId);
      expect(result).toBe(false);
    });
  });

  describe('destroySession', () => {
    it('should delete the session', async () => {
      const sessionId = 'test-session-id';
      await sessionService.destroySession(sessionId);

      expect(redisService.del).toHaveBeenCalledWith(
        expect.stringContaining(sessionId),
      );
    });
  });

  describe('getUserSessions', () => {
    const userId = 'test-user-id';

    it('should return all sessions for user', async () => {
      const mockSessions = ['session:1', 'session:2', 'session:3'];

      const mockSessionData = {
        'session:1': JSON.stringify({ userId }),
        'session:2': JSON.stringify({ userId: 'other-user' }),
        'session:3': JSON.stringify({ userId }),
      };

      mockRedisService.keys.mockResolvedValue(mockSessions);
      mockRedisService.get.mockImplementation((key) =>
        Promise.resolve(mockSessionData[key]),
      );

      const result = await sessionService.getUserSessions(userId);

      expect(result).toHaveLength(2);
      expect(result).toContain('1');
      expect(result).toContain('3');
    });
  });
});


// modules/mail/mail.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { MailerService } from './mail.service';

@Module({
  imports: [ConfigModule],
  providers: [MailerService],
  exports: [MailerService],
})
export class MailModule {}

// modules/mail/mail.service.ts
import { Injectable, Logger } from '@nestjs/common';
import * as nodemailer from 'nodemailer';
import { ConfigService } from '@nestjs/config';

export interface MailOptions {
  to: string;
  subject: string;
  text?: string;
  html?: string;
}

@Injectable()
export class MailerService {
  private transporter: nodemailer.Transporter;
  private readonly logger = new Logger(MailerService.name);

  constructor(private configService: ConfigService) {}

  async onModuleInit() {
    await this.initializeTransporter();
  }

  private async initializeTransporter() {
    try {
      if (this.configService.get('NODE_ENV') === 'development') {
        this.logger.debug('Using Ethereal Email for development');
  
        const cachedTestAccount = this.configService.get('ETHEREAL_TEST_ACCOUNT');
        let testAccount;
  
        if (cachedTestAccount) {
          testAccount = JSON.parse(cachedTestAccount);
        } else {
          testAccount = await nodemailer.createTestAccount();
          this.configService.set('ETHEREAL_TEST_ACCOUNT', JSON.stringify(testAccount));
        }
  
        this.logger.debug('Ethereal Email test account:', {
          user: testAccount.user,
          pass: testAccount.pass,
          web: 'https://ethereal.email'
        });
  
        this.transporter = nodemailer.createTransport({
          host: 'smtp.ethereal.email',
          port: 587,
          secure: false,
          auth: {
            user: testAccount.user,
            pass: testAccount.pass,
          },
        });
      } else {
        // For production, use real SMTP settings
        this.transporter = nodemailer.createTransport({
          host: this.configService.get('SMTP_HOST'),
          port: this.configService.get('SMTP_PORT'),
          secure: this.configService.get('SMTP_SECURE') === 'true',
          auth: {
            user: this.configService.get('SMTP_USER'),
            pass: this.configService.get('SMTP_PASS'),
          },
        });
      }
  
      // Verify the connection
      await this.transporter.verify();
      this.logger.log('Mail transporter initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize mail transporter:', error);
      throw error;
    }
  }

  async sendMail(options: MailOptions): Promise<boolean> {
    try {
      if (!this.transporter) {
        await this.initializeTransporter();
      }

      const info = await this.transporter.sendMail({
        from: this.configService.get('SMTP_FROM') || 'noreply@nibblix.com',
        ...options,
      });

      if (this.configService.get('NODE_ENV') === 'development') {
        const previewUrl = nodemailer.getTestMessageUrl(info);
        this.logger.debug(`Email Preview URL: ${previewUrl}`);
      }

      this.logger.log(`Email sent: ${info.messageId}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to send email: ${error.message}`, error.stack);
      return false;
    }
  }

  // Helper method for password reset emails
  async sendPasswordReset(email: string, token: string): Promise<boolean> {
    const resetLink = `${this.configService.get('FRONTEND_URL')}/reset-password?token=${token}`;
    
    return this.sendMail({
      to: email,
      subject: 'Password Reset Request',
      html: `
        <h1>Password Reset Request</h1>
        <p>You requested to reset your password. Click the link below to proceed:</p>
        <a href="${resetLink}">Reset Password</a>
        <p>If you didn't request this, please ignore this email.</p>
        <p>This link will expire in 30 minutes.</p>
      `,
    });
  }

  // Helper method for welcome emails
  async sendWelcome(email: string, username: string): Promise<boolean> {
    return this.sendMail({
      to: email,
      subject: 'Welcome to Nibblix',
      html: `
        <h1>Welcome to Nibblix, ${username}!</h1>
        <p>Thank you for joining our platform. We're excited to have you on board!</p>
        <p>If you have any questions, feel free to contact our support team.</p>
      `,
    });
  }
}

// modules/middleware/middleware.module.ts
import { Module } from '@nestjs/common';
import { SessionMiddleware } from '../auth/middleware/session.middleware';
import { RateLimitMiddleware } from '../auth/middleware/rate-limit.middleware';
import { RequestLoggerMiddleware } from '../auth/middleware/request-logger.middleware';
import { SessionService } from '../auth/session.service';
import { RedisModule } from '../../redis/redis.module';

@Module({
  imports: [RedisModule],
  providers: [
    SessionMiddleware,
    RateLimitMiddleware,
    RequestLoggerMiddleware,
    SessionService,
  ],
  exports: [SessionMiddleware, RateLimitMiddleware, RequestLoggerMiddleware],
})
export class MiddlewareModule {}


// prisma/prisma.module.ts
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}


// prisma/prisma.service.ts
import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  private readonly logger = new Logger(PrismaService.name);

  async onModuleInit() {
    try {
      await this.$connect();
      this.logger.log('Successfully connected to database');

      // Test the connection by running a simple query
      await this.$queryRaw`SELECT 1`;
      this.logger.log('Database connection verified');
    } catch (error) {
      this.logger.error('Failed to connect to database:', error);
      throw error;
    }
  }
}


// redis/redis.module.ts
import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { RedisService } from './redis.service';
import { redisStore } from 'cache-manager-redis-store';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    CacheModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        store: redisStore as any,
        url: configService.get('REDIS_URL') || 'redis://redis:6379',
        isGlobal: true,
        ttl: 60 * 60 * 24, // 24 hours
      }),
      inject: [ConfigService],
    }),
  ],
  providers: [RedisService],
  exports: [RedisService, CacheModule],
})
export class RedisModule {}


// redis/redis.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class RedisService {
  constructor(@Inject(CACHE_MANAGER) private readonly cacheManager: Cache) {}

  async get(key: string): Promise<any> {
    return this.cacheManager.get(key);
  }

  async set(key: string, value: any, ttl: number): Promise<void> {
    await this.cacheManager.set(key, value, ttl * 1000);
  }

  async del(key: string): Promise<void> {
    await this.cacheManager.del(key);
  }

  async ttl(key: string): Promise<number> {
    const client = (this.cacheManager.store as any).getClient();
    return client.ttl(key);
  }

  async keys(pattern: string): Promise<string[]> {
    const client = (this.cacheManager.store as any).getClient();
    return client.keys(pattern);
  }
}

